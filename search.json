[{"categories":["golang"],"content":"首先我们先明确下 json 包下 Unmarshal() 函数是什么： 它是 Go 语言标准库 encoding/json 中的一个函数，用于将 JSON 数据解析为 Go 语言中的数据结构。它的作用是将一个 JSON 格式的字节切片（[]byte）转换为对应的 Go 语言数据类型，如结构体、切片、映射等。 其次了解了它的作用后，再来看下这个坑点： 假设有一个 json 串如下： { \"id\": 1, \"name\": \"张三\", \"age\": 20 } 现在要将它解析成一个 map，拿到 json 原始的数据，方便后续处理： func main() { str := \"{\\\"id\\\":1,\\\"name\\\":\\\"张三\\\",\\\"age\\\":20}\" jsonMap := make(map[string]interface{}) json.Unmarshal([]byte(str), \u0026amp;jsonMap) // 遍历map for key, value := range jsonMap { fmt.Printf(\"key: %s, value: %v\\n\", key, value) } } // 输出： // key: id, value: 1 // key: name, value: 张三 // key: age, value: 20 这样看着确实没什么问题，每个 key、value 值都是按照预期输出； 现在我把 json 调整一下，假设 id 是一个毫秒级时间戳 1736325205000（13 位）： func main() { str := \"{\\\"id\\\":1736325205000,\\\"name\\\":\\\"张三\\\",\\\"age\\\":20}\" jsonMap := make(map[string]interface{}) json.Unmarshal([]byte(str), \u0026amp;jsonMap) // 遍历map for key, value := range jsonMap { fmt.Printf(\"key: %s, value: %v\\n\", key, value) } } // 输出 // key: id, value: 1.736325205e+12 // key: name, value: 张三 // key: age, value: 20 此时坑来了， id 的值变成了一个科学计数法的字符串，显然这不符合我的预期； 那么为什么会变成这样呢？ 首先观察到我使用了 %v 进行处理，然而 json 中原本的数据是一个 int，我应该用处理 int 的占位符 %d ： func main() { str := \"{\\\"id\\\":1736325205000,\\\"name\\\":\\\"张三\\\",\\\"age\\\":20}\" jsonMap := make(map[string]interface{) json.Unmarshal([]byte(str), \u0026amp;jsonMap) fmt.Printf(\"%d\",jsonMap[\"id\"]) } // 输出 // %!d(float64=1.736325205e+12) 到这里本以为是 ok 的，结果输出了这么个玩意，仔细读一下发现 float64 ，输出这个的原因是我要把一个 float64 的元素强行用 int 类型的占位符进行处理； 所以现在进一步清晰了，json.Unmarshal 函数会把 id 转为 float64； 那么问题又来了，为什么它会把 id 转为 float64 类型呢？id == 1 的时候为什么能正常输出呢？ 进源码，看看函数内部做了什么： func Unmarshal(data []byte, v any) error { // Check for well-formedness. // Avoids filling out half a data structure // before discovering a JSON syntax error. var d decodeState err := checkValid(data, \u0026amp;d.scan) if err != nil { return err } d.init(data) return d.unmarshal(v) } // 可以看到 checkValid() 方法引用了 decodeState 结构体 // 进结构体里看下： // decodeState represents the state while decoding a JSON value. type decodeState struct { data []byte off int // next read offset in data opcode int // last read result scan scanner errorContext *errorContext savedError error useNumber bool disallowUnknownFields bool } // 初步观察有个 bool 类型的 useNumber 属性 // 接着看下这个结构体具体的实现方法： // convertNumber converts the number literal s to a float64 or a Number // depending on the setting of d.useNumber. func (d *decodeState) convertNumber(s string) (any, error) { if d.useNumber { return Number(s), nil } f, err := strconv.ParseFloat(s, 64) if err != nil { return nil, \u0026amp;UnmarshalTypeError{Value: \"number \" + s, Type: reflect.TypeOf(0.0), Offset: int64(d.off)} } return f, nil } // 到这里大概能清楚，是这个方法把我的 id 转成了 float64，但是再转之前还有一层 if 会把原始值输出； // 接下来就回去上一级，看看 d.scan 到底做了什么： // 努力中... // ——————看不懂 经过多方查找： 理论上 json 会把超过 int64 长度的数字转成 float64，但是这个说法经实践不成立，毫秒级时间戳 13 位，远没有超过 int64 的最大长度； 多次翻阅资料后，有一个说法比较靠谱： 当处理非常大的整数（如毫秒级的时间戳）时，如果直接使用 Go 语言中的整数类型（如 int 或 int64），可能会因为超出这些类型的表示范围而导致溢出。虽然 int64 类型在大多数情况下可以容纳毫秒级的时间戳，但为了确保能够处理所有可能的 JSON 数字，encoding/json 包选择了 float64 类型作为默认解析结果。 到这里其实我们最初的目的也轻松处理： func main() { str := \"{\\\"id\\\":1736325205000,\\\"name\\\":\\\"张三\\\",\\\"age\\\":20}\" jsonMap := make(map[string]interface{}) json.Unmarshal([]byte(str), \u0026amp;jsonMap) // 断言类型为 float64 fmt.Println(jsonMap[\"id\"]) if f, ok := jsonMap[\"id\"].(float64); ok { fmt.Println(int(f)) } } // 输出 // 1736325205000 ","date":"2025-01-12","objectID":"/posts/json_unmarshall_parsing_numeric_types/:0:0","tags":["golang"],"title":"Json.Unmarshal 解析数字类型（踩坑）","uri":"/posts/json_unmarshall_parsing_numeric_types/"},{"categories":["golang"],"content":"高效地处理多个数据源并将其整合为有意义的结果是开发中一项重要的任务。Go 语言，以其强大的并发特性，为我们提供了优雅而高效的解决方案。那么我们探讨一下如何利用 Go 语言的协程，同时调用多个接口获取数据，并将这些数据无缝地合并为一个完整的数据集。 先假定一个场景：现有一需求，需要请求n个接口（暂定为3个）获取接口数据，然后对数据进行二次处理并返回。 按照过往的经验，我们会依次请求接口拿到数据暂存，最后对数据进行包装处理，这种自上而下的处理方式其实并无不妥，现在想要提高下效率，利用牺牲cpu资源来换取查询性能。 先模拟创建几个接口，分别返回(k1，v1)、(k2，v2)、(k3，v4)： // 模拟接口A func getDataFromA() map[string]interface{} { return map[string]interface{}{ \"key1\": \"value1\", } } // 模拟接口B func getDataFromB() map[string]interface{} { return map[string]interface{}{ \"key2\": \"value2\", } } // 模拟接口C func getDataFromC() map[string]interface{} { return map[string]interface{}{ \"key3\": \"value3\", } } 开启协程分别请求上述接口： 首先得思考一个问题，协程执行不保证顺序，请求到的数据应该怎么保存？怎么判断全部协程都执行完毕？怎么拿到全部的数据？ 上述接口定义中返回的数据均是map，那么我完全可以用map来保存数据，所以我定义方法就可以这么定义： func getAllData() map[string]interface{} { return nil // 暂时先不做处理 } 为了防止主协程先于其他执行结束，需要引入 sync.WaitGroup 包控制；所有协程返回的数据，可以用通道来暂存，make 一个容量为 3 的 Channel： func getAllData() map[string]interface{} { var wg sync.WaitGroup resultChan := make(chan map[string]interface{}, 3) return nil // 暂时先不做处理 } 接下来就可以开启协程去调用: func getAllData() map[string]interface{} { var wg sync.WaitGroup resultChan := make(chan map[string]interface{}, 3) wg.Add(3) go func() { defer wg.Done() resultChan \u003c- getDataFromA() }() go func() { defer wg.Done() resultChan \u003c- getDataFromB() }() go func() { defer wg.Done() resultChan \u003c- getDataFromC() }() wg.Wait() close(resultChan) return nil // 暂时先不做处理 } 最后可以对数据做个简单处理，封装成一个大map返回，实际业务当然按需处理： newMap := make(map[string]interface{}) for res := range resultChan { for k, v := range res { newMap [k] = v } } return newMap 执行验证返回结果： [Running] go run \"main.go\" map[key1:value1 key2:value2 key3:value3] ","date":"2025-01-12","objectID":"/posts/collaborative_processing_of_multiple_interfaces/:0:0","tags":["golang","并发","协程"],"title":"Go 语言并发实战：利用协程处理多个接口的 Map 数据融合","uri":"/posts/collaborative_processing_of_multiple_interfaces/"},{"categories":["golang"],"content":" 在如今的编程领域，一个程序能够同时处理多个任务的能力非常重要，而 Golang 在并发编程方面表现十分出色，具有很多独特的优势。 ","date":"2025-01-12","objectID":"/posts/the_concurrency_advantage_of_go/:0:0","tags":["golang","并发"],"title":"Go 的并发优势","uri":"/posts/the_concurrency_advantage_of_go/"},{"categories":["golang"],"content":"一、轻量级的协程（Goroutine） 在传统的像 Java 这样的编程语言中，创建线程来实现并发往往需要较大的资源开销和复杂的管理。但在 Golang 里，有了 Goroutine 就截然不同。 Goroutine 的创建几乎不费力气，我们可以毫无压力地同时启动成千上万的 Goroutine 来完成不同的任务，而且不用担心资源被大量消耗。 举个例子： package main import ( \"fmt\" \"time\" ) func task() { fmt.Println(\"Hello Goroutine!\") } func main() { go task() time.Sleep(1 * time.Second) } 在这段代码里，我们用 go task() 轻松地启动了一个 Goroutine 去执行 task 函数。 当然这样可能更直观： package main import ( \"fmt\" \"time\" ) func main() { go func() { fmt.Println(\"Hello Goroutine!\") }() time.Sleep(1 * time.Second) } ","date":"2025-01-12","objectID":"/posts/the_concurrency_advantage_of_go/:1:0","tags":["golang","并发"],"title":"Go 的并发优势","uri":"/posts/the_concurrency_advantage_of_go/"},{"categories":["golang"],"content":"二、高效的通道（Channel） 在并发编程中，不同的任务之间需要数据通信。Golang 里的通道（Channel）就像是一个专门的管道，使得数据通信安全又高效。 package main import \"fmt\" func main() { ch := make(chan int) // 无缓冲的通道 go func() { ch \u003c- 1 }() num := \u003c-ch fmt.Println(num) } 通过这个通道 ch，我们成功地在两个不同的 Goroutine 之间传递了数据。 ","date":"2025-01-12","objectID":"/posts/the_concurrency_advantage_of_go/:2:0","tags":["golang","并发"],"title":"Go 的并发优势","uri":"/posts/the_concurrency_advantage_of_go/"},{"categories":["golang"],"content":"三、优秀的内存管理和并发调度 在编程语言中，内存管理和并发调度是影响程序性能和稳定性的关键因素。Golang 在这两个方面展现出了卓越的特性。 Golang 拥有一套自动且高效的内存回收机制。这意味着开发者无需像在 Java 等语言中那样，时刻关注内存的分配与释放，避免了因手动管理内存而可能导致的内存泄漏和野指针等问题。这种自动内存管理机制不仅减轻了开发者的负担，还提高了程序的可靠性和可维护性。 同时，Golang 的并发调度机制极具智能性。它能够根据系统的负载和各个 Goroutine 的状态，合理地分配 CPU 资源，确保每个 Goroutine 都能获得公平的执行机会。与 Java 等语言的线程调度相比，Golang 的调度更加轻量和灵活，能够在高并发场景下实现更高效的资源利用，从而显著提升程序的整体性能和响应速度。 ","date":"2025-01-12","objectID":"/posts/the_concurrency_advantage_of_go/:3:0","tags":["golang","并发"],"title":"Go 的并发优势","uri":"/posts/the_concurrency_advantage_of_go/"},{"categories":["golang"],"content":"四、简洁而强大的并发编程模型 Golang 的并发编程模型以其简洁性和强大的功能而备受赞誉。 与 Java 等语言中相对复杂的并发控制机制（如锁、条件变量等）不同，Golang 提供了一种更为直观和易于理解的方式来处理并发。Goroutine 和 Channel 的组合使用，使得并发任务的创建、通信和同步变得清晰明了。开发者可以轻松地创建多个并发执行的任务，并通过 Channel 安全、高效地进行数据交换和协调。 此外，Golang 的并发错误处理机制也更加简洁和有效。它能够帮助开发者更快速地定位和解决并发环境中可能出现的问题，减少了因并发导致的错误排查难度和时间成本。这种简洁而强大的并发编程模型，极大地提高了开发者的生产效率，使他们能够更加专注于业务逻辑的实现，而不必在复杂的并发控制细节上耗费过多精力。 ","date":"2025-01-12","objectID":"/posts/the_concurrency_advantage_of_go/:4:0","tags":["golang","并发"],"title":"Go 的并发优势","uri":"/posts/the_concurrency_advantage_of_go/"},{"categories":["golang"],"content":"下载Golang 官网链接：https://golang.google.cn/dl/ ","date":"2025-01-12","objectID":"/posts/golang_development_environment/:1:0","tags":["golang"],"title":"Golang 开发环境搭建","uri":"/posts/golang_development_environment/"},{"categories":["golang"],"content":"配置环境 安装好之后须添加如下环境变量： 变更名 变量值 说明 GOPATH E:\\gowork Go语言的工作目录，存放自己编写的 .go 文件、项目、包、编译的二进制文件等 GOROOT D:\\go1.18 Go的安装路径 开启go mod 及配置国内代理： go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct ","date":"2025-01-12","objectID":"/posts/golang_development_environment/:2:0","tags":["golang"],"title":"Golang 开发环境搭建","uri":"/posts/golang_development_environment/"},{"categories":["golang"],"content":"配置vscode 安装 Go、vscode-go-syntax 两插件 届时，vscode 会弹出需要安装其他 go 扩展的提示，只需要 Install All 即可 ","date":"2025-01-12","objectID":"/posts/golang_development_environment/:3:0","tags":["golang"],"title":"Golang 开发环境搭建","uri":"/posts/golang_development_environment/"},{"categories":null,"content":"关于我 一名后端工程师，会点 Java 会点 Golang 偶尔也玩 Python。 工作三年有余，做过金融，也做过CRM，目前在某一线大厂工作。 感兴趣的事，就爱折腾到底，为了那一丝成就感，哪怕微不足道。 ","date":"2025-01-12","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于博客 2018 - 2019：大学初始，开启了编程生涯，白天上课，晚上 bilibili，后来认识到了 遇见狂胜说 ，从而开启了博客之路。 2019 - 2020：在 博客园 注册自己的第一个博客，发表了几篇随笔，收获不少访问量，心中大喜。 2020 - 2021：由于实在接受不了博客园充斥着满满复古味道的 UI ，期间自己不断的网上找美化教程，始终不敬我意，而后转战 CSDN 。 2021 - 2024：长期混迹在 CSDN ，期间也发表些许文章，收获众多点赞收藏，文章也被多次转载，曾经也上过周榜Top 5。 2025 年 1 月：因为 CSDN 吃相实在太难看（广告不断，机器人太多，抄袭严重），辗转反侧，决定注销账号，重头再来，于是开启了 Github Page 打造属于自己的一亩三分地。 2026 年 ：未来继续折腾…… …… 免责声明 欢迎访问本个人站点。但请注意，您在本站发表的任何评论都将被记录并保存。为保护您的个人隐私及遵守法律法规，请勿张贴任何涉及个人隐私的信息。同时，您在发表言论时，请务必遵守中华人民共和国及其它国家和地区的相关法律法规，以避免承担不必要的法律责任。 本站点可能包含引用、摘录或转载自第三方的文字、图片、视频等内容。这些第三方内容的引用旨在传递更多信息，而非代表本站赞同其观点或认可其真实性。对于上述第三方内容的准确性、安全性和完整性，本站不作任何保证或承诺。 在阅读、下载及使用本站点提供的内容时，请您自行判断并承担相应风险。如因使用本站内容导致您或您的网站遭受任何形式的损失或伤害，本站不承担任何责任。 版权声明 除特殊声明外，本站遵循 CC BY-NC 4.0 协议,允许您自由分享与演绎，但请务必遵守以下原则： 署名与出处：分享或演绎时，请明确注明原始内容的作者及来源，以示尊重版权。 非商业使用：所有使用、分享或演绎均限于非商业目的，不得用于盈利活动。 相同条件共享：确保其他用户能在相同条件下访问和使用您分享或演绎的内容。 ","date":"2025-01-12","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"}]