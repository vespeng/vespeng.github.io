[{"categories":["golang"],"content":"在 Go 项目的开发过程中，能够在不同的环境（如开发、测试、生产）中进行灵活部署是至关重要的。不同环境通常需要不同的配置，如服务器端口、数据库连接信息、缓存设置等。 对于 Java 的 SpringBoot 框架来说，可以直接在 application.yml 中指定一个环境配置文件，通常application_dev.yml 代表开发环境，那么 go 可否参考这种方式呢？ 接下来本文将详细介绍如何使用多种方式来实现多环境开发部署，重点围绕 config.yaml 文件和 config.go 文件来进行配置读取和环境区分。 ","date":"2025-01-25","objectID":"/posts/go_practical_multi_environment_development/:0:0","tags":["golang","gin"],"title":"Go 项目实战：如何部署多环境开发","uri":"/posts/go_practical_multi_environment_development/"},{"categories":["golang"],"content":"Go 中的系统环境变量 先来解释一个概念，在 Go 语言中，系统环境变量是操作系统为每个进程提供的键值对集合。这些环境变量可以用于配置应用程序的行为、连接数据库、设置日志级别等。Go 提供了标准库 os 来读取和操作这些环境变量。 ","date":"2025-01-25","objectID":"/posts/go_practical_multi_environment_development/:1:0","tags":["golang","gin"],"title":"Go 项目实战：如何部署多环境开发","uri":"/posts/go_practical_multi_environment_development/"},{"categories":["golang"],"content":"实战 ","date":"2025-01-25","objectID":"/posts/go_practical_multi_environment_development/:2:0","tags":["golang","gin"],"title":"Go 项目实战：如何部署多环境开发","uri":"/posts/go_practical_multi_environment_development/"},{"categories":["golang"],"content":"1. 编写.env文件 在项目根目录下新建一个 .env 文件，配置如下： APP_ENV=dev ","date":"2025-01-25","objectID":"/posts/go_practical_multi_environment_development/:2:1","tags":["golang","gin"],"title":"Go 项目实战：如何部署多环境开发","uri":"/posts/go_practical_multi_environment_development/"},{"categories":["golang"],"content":"2. 获取环境变量 使用 os.Getenv 函数可以获取指定名称的环境变量值。 env := os.Getenv(\"APP_ENV\") APP_ENV 是一个环境变量名，用于标识应用程序的运行环境（如开发、测试、生产等）。 如果 APP_ENV 未设置，os.Getenv(\"APP_ENV\") 将返回空字符串。 ","date":"2025-01-25","objectID":"/posts/go_practical_multi_environment_development/:2:2","tags":["golang","gin"],"title":"Go 项目实战：如何部署多环境开发","uri":"/posts/go_practical_multi_environment_development/"},{"categories":["golang"],"content":"3. 设置默认值 我们需要一个默认的环境，如果 APP_ENV 未设置，将其设为 \"dev\"： env := os.Getenv(\"APP_ENV\") if env == \"\" { env = \"dev\" // 默认环境为 dev } 这样可以确保即使没有显式设置 APP_ENV，程序也能有一个合理的默认行为。 ","date":"2025-01-25","objectID":"/posts/go_practical_multi_environment_development/:2:3","tags":["golang","gin"],"title":"Go 项目实战：如何部署多环境开发","uri":"/posts/go_practical_multi_environment_development/"},{"categories":["golang"],"content":"4. 加载 .env 文件 使用 github.com/joho/godotenv 包来加载 .env 文件中的环境变量。.env 文件通常用于本地开发环境，避免将敏感信息硬编码到代码中，这里其实挺像 vue 的环境加载方式。 err := godotenv.Load() if err != nil { return fmt.Errorf(\"加载 .env 文件失败: %v\", err) } 这行代码会读取项目根目录下的 .env 文件，并将其中定义的环境变量加载到当前进程中。 ","date":"2025-01-25","objectID":"/posts/go_practical_multi_environment_development/:2:4","tags":["golang","gin"],"title":"Go 项目实战：如何部署多环境开发","uri":"/posts/go_practical_multi_environment_development/"},{"categories":["golang"],"content":"5. 动态选择配置文件 根据 APP_ENV 的值，动态选择不同的配置文件： viper.AddConfigPath(\"./config\") viper.SetConfigName(fmt.Sprintf(\"config_%s\", env)) viper.SetConfigType(\"yaml\") 这段代码会根据 APP_ENV 的值（例如 dev 或 production），选择对应的配置文件（如 config_dev.yaml 或 config_prod.yaml）。这样可以根据不同的环境加载不同的配置。 ","date":"2025-01-25","objectID":"/posts/go_practical_multi_environment_development/:2:5","tags":["golang","gin"],"title":"Go 项目实战：如何部署多环境开发","uri":"/posts/go_practical_multi_environment_development/"},{"categories":["golang"],"content":"6. 解析配置文件 使用 viper.Unmarshal 将配置文件的内容解析到结构体中： Conf = \u0026Config{} err = viper.Unmarshal(Conf) if err != nil { return fmt.Errorf(\"解析配置文件失败: %v\", err) } viper.Unmarshal 会将配置文件中的键值对映射到结构体字段上，前提是结构体字段标签（如 yaml 和 mapstructure）与配置文件中的键匹配。 通过上述方式，我们可以根据项目的实际需求和情况，确保项目在不同环境下都能正确配置并稳定运行。 ","date":"2025-01-25","objectID":"/posts/go_practical_multi_environment_development/:2:6","tags":["golang","gin"],"title":"Go 项目实战：如何部署多环境开发","uri":"/posts/go_practical_multi_environment_development/"},{"categories":["golang"],"content":"在 Go 项目开发中，日志处理是一项至关重要的任务。它不仅有助于我们在开发过程中调试代码，还能在生产环境中帮助我们快速定位问题。本文将详细介绍如何在 Go 项目中优雅地处理日志，包括日志的级别、格式、输出以及如何使用第三方日志库等方面。 ","date":"2025-01-22","objectID":"/posts/go_practical_processing_log/:0:0","tags":["golang","gin"],"title":"Go 项目实战：如何优雅的处理日志","uri":"/posts/go_practical_processing_log/"},{"categories":["golang"],"content":"一、日志级别的重要性 日志级别是控制日志输出的重要手段。通过设置不同的日志级别，我们可以灵活地控制日志的详细程度。在 Go 语言中，常见的日志级别有DEBUG、INFO、WARN、ERROR和FATAL。不同级别的日志用于记录不同类型的信息，例如： DEBUG：用于记录详细的调试信息，仅在开发环境中启用。 INFO：用于记录正常的业务流程信息，例如请求的处理、数据的加载等。 WARN：用于记录可能存在的问题或异常情况，但不影响系统的正常运行。 ERROR：用于记录严重的错误信息，这些错误可能导致系统无法正常运行。 FATAL：用于记录非常严重的错误信息，这些错误会导致程序立即退出。 ","date":"2025-01-22","objectID":"/posts/go_practical_processing_log/:1:0","tags":["golang","gin"],"title":"Go 项目实战：如何优雅的处理日志","uri":"/posts/go_practical_processing_log/"},{"categories":["golang"],"content":"二、日志格式的选择 日志格式的选择对于日志的可读性和分析性至关重要。一个好的日志格式应该包含足够的信息，以便我们能够快速定位问题。常见的日志格式有 JSON、XML 和文本格式等。 在 Go 语言中，我们可以使用第三方库来实现不同的日志格式。例如，使用 logrus 库可以轻松地将日志格式化为 JSON 格式： package main import ( \"github.com/sirupsen/logrus\" ) func main() { // 设置日志格式为JSON logrus.SetFormatter(\u0026logrus.JSONFormatter{}) // 记录不同级别的日志 logrus.Debug(\"这是一条DEBUG级别的日志\") logrus.Info(\"这是一条INFO级别的日志\") logrus.Warn(\"这是一条WARN级别的日志\") logrus.Error(\"这是一条ERROR级别的日志\") logrus.Fatal(\"这是一条FATAL级别的日志\") } ","date":"2025-01-22","objectID":"/posts/go_practical_processing_log/:2:0","tags":["golang","gin"],"title":"Go 项目实战：如何优雅的处理日志","uri":"/posts/go_practical_processing_log/"},{"categories":["golang"],"content":"三、日志输出的方式 日志输出的方式有很多种，例如输出到控制台、文件、数据库等。在 Go 语言中，我们可以使用标准库的log包来实现基本的日志输出功能。例如，使用标准库 log.Println 方法可以将日志输出到控制台： package main import \"log\" func main() { // 记录日志到控制台 log.Println(\"这是一条日志信息\") } 如果需要将日志输出到文件，我们可以这么做： package main import ( \"log\" \"os\" ) func main() { // 创建日志文件 file, err := os.OpenFile(\"app.log\", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644) if err != nil { log.Fatal(err) } defer file.Close() // 设置日志输出到文件 log.SetOutput(file) // 记录日志 log.Println(\"这是一条日志信息\") } 除了常见的输出到控制台或指定文件，我们还可以将日志输出到数据库、Elasticsearch 等其他存储介质中。具体的实现方式还需根据实际需求进行选择。 ","date":"2025-01-22","objectID":"/posts/go_practical_processing_log/:3:0","tags":["golang","gin"],"title":"Go 项目实战：如何优雅的处理日志","uri":"/posts/go_practical_processing_log/"},{"categories":["golang"],"content":"四、使用第三方日志库 虽然说 Go 语言的标准库提供了基本的日志处理功能，但在实际项目中，往往需要结合第三方更为强大的库来满足日常需求： logrus：一个功能强大的日志库，支持多种日志格式、日志级别、日志输出方式等。 zap：一个高性能的日志库，具有快速、灵活、可扩展等特点。 zerolog：一个极简主义的日志库，专注于提供高性能和简单的 API。 ps: 上述简介来自于AI，注意甄别 这些第三方日志库都提供了丰富的功能和灵活的配置选项，可以帮助我们更好地处理日志。在这里个人比较推荐 logrus ，不过具体需求还是得具体选择。 ","date":"2025-01-22","objectID":"/posts/go_practical_processing_log/:4:0","tags":["golang","gin"],"title":"Go 项目实战：如何优雅的处理日志","uri":"/posts/go_practical_processing_log/"},{"categories":["golang"],"content":"五、实战 介绍再多也是空谈，接下来结合具体的项目，我们优雅的配置一下。 默认项目已经安装 logrus ，没有的话可以执行下如下命令： go get github.com/sirupsen/logrus ","date":"2025-01-22","objectID":"/posts/go_practical_processing_log/:5:0","tags":["golang","gin"],"title":"Go 项目实战：如何优雅的处理日志","uri":"/posts/go_practical_processing_log/"},{"categories":["golang"],"content":"1、配置config.yaml 为了方便随时更改切换 log 级别或者输出格式，我们可以单独抽离出来实现配置化： log: format: json # 输出格式 level: debug # 日志级别 report_caller: true # 是否开启调试 ","date":"2025-01-22","objectID":"/posts/go_practical_processing_log/:5:1","tags":["golang","gin"],"title":"Go 项目实战：如何优雅的处理日志","uri":"/posts/go_practical_processing_log/"},{"categories":["golang"],"content":"2.配置config.go 有了参数配置，还缺一步解析： 具体的解析可以参考 Go 项目实战：搭建高效的 Gin Web 目录结构 ","date":"2025-01-22","objectID":"/posts/go_practical_processing_log/:5:2","tags":["golang","gin"],"title":"Go 项目实战：如何优雅的处理日志","uri":"/posts/go_practical_processing_log/"},{"categories":["golang"],"content":"2、新建init_logger.go 在这里我们统一配置 logrus 参数，包括日志级别，输出格式： package initializers import ( log \"github.com/sirupsen/logrus\" ) // InitializeLogger 设置日志输出 func InitializeLogger() error { // 设置日志格式 switch config.Conf.Log.Format { case \"json\": log.SetFormatter(\u0026log.JSONFormatter{}) case \"text\": log.SetFormatter(\u0026log.TextFormatter{}) default: log.SetFormatter(\u0026log.JSONFormatter{}) } // 设置日志级别 switch config.Conf.Log.Level { case \"debug\": log.SetLevel(log.DebugLevel) case \"info\": log.SetLevel(log.InfoLevel) case \"warn\": log.SetLevel(log.WarnLevel) case \"error\": log.SetLevel(log.ErrorLevel) case \"fatal\": log.SetLevel(log.FatalLevel) case \"panic\": log.SetLevel(log.PanicLevel) default: log.SetLevel(log.InfoLevel) } // 设置打印调用信息 log.SetReportCaller(config.Conf.Log.ReportCaller) return nil } ","date":"2025-01-22","objectID":"/posts/go_practical_processing_log/:5:3","tags":["golang","gin"],"title":"Go 项目实战：如何优雅的处理日志","uri":"/posts/go_practical_processing_log/"},{"categories":["golang"],"content":"3、输出日志到文件 控制台打印日志，肯定是不满足一个项目的正常使用的，我们非常有必要将日志持久化到一个单独文件中。 但是这样还不够，会存在另一个问题：日志文件会越来越大后期不利于日志排查。所以还需要对日志进行一个分割，最好的实践方式就是按天分割，所以我们接着在上述初始化文件中去做设置： package initializers import ( \"github.com/lestrrat-go/file-rotatelogs\" log \"github.com/sirupsen/logrus\" \"os\" \"time\" \"your_project/config\" ) // InitializeLogger 设置日志输出并初始化日志文件 func InitializeLogger() error { // 设置日志格式 ... // 设置日志级别 ... // 设置打印调用信息 ... // 创建日志目录 logDir := \"../logs\" err := os.MkdirAll(logDir, 0755) if err != nil { log.Fatalf(\"创建日志目录失败: %v\", err) } // 设置日志输出，按天切割 logFilePath := logDir + \"/app.%Y%m%d.log\" writer, err := rotatelogs.New( logFilePath, rotatelogs.WithLinkName(logDir+\"/app.log\"), rotatelogs.WithMaxAge(7*24*time.Hour), // 保留7天 rotatelogs.WithRotationTime(24*time.Hour), // 每天切割一次 ) if err != nil { log.Fatalf(\"设置日志输出失败: %v\", err) } log.SetOutput(writer) return nil } ","date":"2025-01-22","objectID":"/posts/go_practical_processing_log/:5:4","tags":["golang","gin"],"title":"Go 项目实战：如何优雅的处理日志","uri":"/posts/go_practical_processing_log/"},{"categories":["golang"],"content":"4、调用InitializeLogger() package main import ( \"fmt\" \"github.com/gin-gonic/gin\" log \"github.com/sirupsen/logrus\" \"your_project/api\" \"your_project/config\" \"your_project/initializers\" ) func main() { // 加载配置文件 err := config.LoadConfig() if err != nil { log.Error(\"配置文件加载错误: %v\", err) return } // 初始化 logger err = InitializeLogger() if err != nil { log.Error(\"logger 初始化错误: %v\", err) return } r := gin.Default() api.SetupRoutes(r, Engine) err = r.Run(fmt.Sprintf(\":%d\", config.Conf.App.Port)) if err != nil { log.Error(\"服务启动错误: %v\", err) return } } 到这里一个完整的日志配置就算是配置好了。 ","date":"2025-01-22","objectID":"/posts/go_practical_processing_log/:5:5","tags":["golang","gin"],"title":"Go 项目实战：如何优雅的处理日志","uri":"/posts/go_practical_processing_log/"},{"categories":["golang"],"content":"引言 在当今迅速迭代的软件开发领域，挑选合适的工具与框架对于项目能否顺利推进至关重要。Gin框架，作为Go语言生态中备受青睐的Web开发框架，凭借其卓越的性能、简洁的设计以及丰富的功能特性，在众多选项中脱颖而出。本文旨在深入剖析如何在使用Gin框架的过程中，构建一个既高效又便于管理的项目架构，助力开发者打造既快速响应又易于维护的Web应用程序。 ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:1:0","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"一、Gin 概述 引入官网的描述：Gin是一个使用Go语言开发的Web框架。 它提供类似Martini的API，但性能更佳，速度提升高达40倍。 如果你是性能和高效的追求者, 你会爱上Gin。 对比Beego框架，Gin框架采用了极简主义的方法，为追求简单和高性能，没有多余文件或目录，他甚至什么也没有，没有集成任何中间件，一个main文件即可启动一个web服务。 正因为如上所述，过分精简对于开发一个项目来说，前期的项目搭建工作就显得尤为重要。 ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:2:0","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"二、项目结构设计 有过Java开发经验的伙伴应该了解，SpringBoot 遵循着MVC的设计理念，这一套设计理念一直沿用至今，他的优秀难以言喻，Gin框架完全可以参照这个模式来做，如下是我个人设计的一套架构： ├── /api │ └── controllers │ │ ├── controller.go │ └── routes.go ├── /cmd │ └── main.go ├── /config │ └── config.go │ └── config.yaml ├── /initializers │ └── init.go ├── /internal │ ├── /models │ │ ├── user.go │ │ ├── role.go │ │ └── ... │ ├── /repositories │ │ ├── user_repository.go │ │ ├── role_repository.go │ │ └── ... │ ├── /services │ │ ├── user_service.go │ │ ├── role_service.go │ │ └── ... ├── /middleware │ └── /errors │ ├── errors.go │ └── ... ├── /tests │ └── ... ├── /utils │ └── ... ├── go.mod └── go.sum ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:3:0","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"三、目录职责 /api 存放包含与API相关的代码。 controllers：存放控制器文件，在route和service之间做中间层，前置处理请求参数等，随后调用服务层逻辑，并返回响应。 routes.go：定义API的路由，即URL路径与控制器方法的映射。 /cmd 存放应用的入口文件。 main.go：是整个应用的入口，在这里启动应用。 /config 存放应用的配置文件和配置加载逻辑。 config.go：包含配置加载和解析的逻辑。 config.yaml：应用的配置文件，通常包含数据库连接信息、服务器设置等。 /initializers 存放应用的初始化逻辑。 init.go：在应用启动时执行一些初始化操作，如数据库连接、中间件设置等。 /internal 存放应用的内部逻辑，这些代码不能被外部包所引入，可根据实际需求进而拆分目录。 models：定义应用的数据模型，通常与数据库表结构对应。 repositories：实现数据访问逻辑，与数据库进行交互。 services：实现业务逻辑，调用repositories中的方法来处理业务需求。 /middleware 存放中间件代码，中间件用于在请求处理流程中的特定阶段执行代码。 errors：处理错误相关的中间件，可能包括记录错误日志、返回统一错误格式等。 /tests 存放测试代码，包括单元测试、集成测试等。 这里的目录结构可以根据需要自行组织，以支持不同类型的测试。 /utils 存放工具函数，这些函数通常被多个包共享。 以上目录结构有助于清晰地分离应用的不同部分，使得代码更加模块化、易于理解和维护。同时，我也参照众多优秀开源项目的目录搭建思想，使其完美遵循了Go语言的最佳实践。 ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:4:0","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"四、实践 目录搭建好后，开始填充代码 下边简单实现集成数据库，配置路由，启动服务 ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:5:0","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"1、配置config 在 config.yaml 文件下配置端口和数据库连接，这里选择xorm： # 基础配置 app: port: 8080 database: driver: mysql source: root:123456@tcp(127.0.0.1:3306)/xxx_table?charset=utf8mb4\u0026parseTime=True\u0026loc=Local 在 config.go 下解析配置 package config import ( \"fmt\" \"github.com/spf13/viper\" ) type Config struct { App AppConfig `yaml:\"app\" mapstructure:\"app\"` Database DatabaseConfig `yaml:\"database\" mapstructure:\"database\"` } type AppConfig struct { Port int `mapstructure:\"port\"` } type DatabaseConfig struct { Driver string `yaml:\"driver\" mapstructure:\"driver\"` Source string `yaml:\"source\" mapstructure:\"source\"` } var Conf *Config // LoadConfig 加载配置文件 func LoadConfig() error { // 设置配置文件路径和名称 viper.AddConfigPath(\"./config\") viper.SetConfigName(\"config\") viper.SetConfigType(\"yaml\") // 读取配置文件 err = viper.ReadInConfig() if err != nil { return fmt.Errorf(\"读取配置文件失败: %v\", err) } // 将配置文件内容解析到 Conf 变量中 Conf = \u0026Config{} err = viper.Unmarshal(Conf) if err != nil { return fmt.Errorf(\"解析配置文件失败: %v\", err) } return nil } ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:5:1","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"2、配置init 数据库及其他的初始化统一放置到 initializers 目录下，即在 init.go 中初始化 mysql，但是为了之后方便管理，新建一个 init_db.go 文件： 如需要加载其他如redis，那就新建 init_redis.go 文件 package initializers import ( _ \"github.com/go-sql-driver/mysql\" \"github.com/go-xorm/xorm\" log \"github.com/sirupsen/logrus\" \"yourProject/config\" ) var Engine *xorm.Engine // InitializeMySQL 数据库初始化 func InitializeMySQL() error { var err error // 创建数据库引擎 Engine, err = xorm.NewEngine(config.Conf.Database.Driver, config.Conf.Database.Source) if err != nil { log.Error(\"数据库初始化失败: %v\", err) return err } // 测试数据库连接 if err = Engine.Ping(); err != nil { log.Error(\"数据库连接失败: %v\", err) return err } return nil } init.go 中调用 InitializeMySQL() package initializers import ( \"fmt\" ) // InitializeAll 初始化所有模块 func InitializeAll() error { err := InitializeMySQL() if err != nil { return fmt.Errorf(\"MySQL初始化错误: %v\", err) } return nil } ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:5:2","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"3、配置mod 在 models 下新建 user_entity.go，注意：这个需要和数据库对应 package models type User struct { Id int64 `xorm:\"pk autoincr 'id'\"` Username string `xorm:\"varchar(255) not null 'username'\"` Password string `xorm:\"varchar(255) not null 'password'\"` } // TableName 方法用于返回表名 func (u User) TableName() string { return \"user\" } ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:5:3","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"4、配置service 在 sevices下新建 user_service.go package services import ( \"github.com/go-xorm/xorm\" \"vesgo/internal/system/models\" ) type UserService struct { engine *xorm.Engine } func NewUserService(engine *xorm.Engine) *UserService { return \u0026UserService{engine: engine} } func (us *UserService) GetUsers() ([]models.User, error) { var users []models.User // 通过 UserEntity 的 TableName 方法获取表名 err := us.engine.Table(models.User{}.TableName()).Find(\u0026users) return users, err } ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:5:4","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"5、配置api routes.go 中设置路由，这里设置路由组，为方便日后迭代 package api import ( \"github.com/gin-gonic/gin\" \"github.com/go-xorm/xorm\" \"your_project/api/controllers/\" \"your_project/internal/services\" ) func SetupRoutes(r *gin.Engine, engine *xorm.Engine) { // 定义用户路由组 user := r.Group(\"/system\") { // 创建 UserService 实例 userService := services.NewUserService(engine) // 创建 UserController 实例 userController := controllers.NewUserController(userService) user.GET(\"/users\", userController.GetUsers) } } package controllers import ( \"github.com/gin-gonic/gin\" \"net/http\" \"your_project/internal/services\" ) type UserController struct { userService *services.UserService } func NewUserController(userService *services.UserService) *UserController { return \u0026UserController{userService: userService} } func (uc *UserController) GetUsers(c *gin.Context) { users, err := uc.userService.GetUsers() if err != nil { c.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to fetch users\"}) return } c.JSON(http.StatusOK, gin.H{\"users\": users}) } ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:5:5","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"6、配置main package main import ( \"fmt\" \"github.com/gin-gonic/gin\" log \"github.com/sirupsen/logrus\" \"your_project/api\" \"your_project/config\" \"your_project/initializers\" ) func main() { // 加载配置文件 err := config.LoadConfig() if err != nil { log.Error(\"配置文件加载错误: %v\", err) return } // 初始化所有模块 err = InitializeAll() if err != nil { log.Error(\"模块初始化错误: %v\", err) return } r := gin.Default() api.SetupRoutes(r, Engine) err = r.Run(fmt.Sprintf(\":%d\", config.Conf.App.Port)) if err != nil { log.Error(\"服务启动错误: %v\", err) return } } 截至这里，基本的一个查询请求就已经构建好了 ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:5:6","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"7、启动项目 cmd目录下直接运行main函数，正常会输出如下信息： Listening and serving HTTP on :8080 接着访问 http://localhost:8080/system/users 正常查询结果回显json如下： { \"users\": [ { \"Id\": 1, \"Username\": \"张三\", \"Password\": \"123456\" } ] } ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:5:7","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":null,"content":"重要 欢迎莅临我的博客，非常期待您能留下宝贵的留言。 ps：私信请移步到主页邮箱联系！ ","date":"2025-01-14","objectID":"/message/:0:0","tags":null,"title":"留言板","uri":"/message/"},{"categories":["golang"],"content":"首先我们先明确下 json 包下 Unmarshal() 函数是什么： 它是 Go 语言标准库 encoding/json 中的一个函数，用于将 JSON 数据解析为 Go 语言中的数据结构。它的作用是将一个 JSON 格式的字节切片（[]byte）转换为对应的 Go 语言数据类型，如结构体、切片、映射等。 其次了解了它的作用后，再来看下这个坑点： 假设有一个 json 串如下： { \"id\": 1, \"name\": \"张三\", \"age\": 20 } 现在要将它解析成一个 map，拿到 json 原始的数据，方便后续处理： func main() { str := \"{\\\"id\\\":1,\\\"name\\\":\\\"张三\\\",\\\"age\\\":20}\" jsonMap := make(map[string]interface{}) json.Unmarshal([]byte(str), \u0026amp;jsonMap) // 遍历map for key, value := range jsonMap { fmt.Printf(\"key: %s, value: %v\\n\", key, value) } } // 输出： // key: id, value: 1 // key: name, value: 张三 // key: age, value: 20 这样看着确实没什么问题，每个 key、value 值都是按照预期输出； 现在我把 json 调整一下，假设 id 是一个毫秒级时间戳 1736325205000（13 位）： func main() { str := \"{\\\"id\\\":1736325205000,\\\"name\\\":\\\"张三\\\",\\\"age\\\":20}\" jsonMap := make(map[string]interface{}) json.Unmarshal([]byte(str), \u0026amp;jsonMap) // 遍历map for key, value := range jsonMap { fmt.Printf(\"key: %s, value: %v\\n\", key, value) } } // 输出 // key: id, value: 1.736325205e+12 // key: name, value: 张三 // key: age, value: 20 此时坑来了， id 的值变成了一个科学计数法的字符串，显然这不符合我的预期； 那么为什么会变成这样呢？ 首先观察到我使用了 %v 进行处理，然而 json 中原本的数据是一个 int，我应该用处理 int 的占位符 %d ： func main() { str := \"{\\\"id\\\":1736325205000,\\\"name\\\":\\\"张三\\\",\\\"age\\\":20}\" jsonMap := make(map[string]interface{) json.Unmarshal([]byte(str), \u0026amp;jsonMap) fmt.Printf(\"%d\",jsonMap[\"id\"]) } // 输出 // %!d(float64=1.736325205e+12) 到这里本以为是 ok 的，结果输出了这么个玩意，仔细读一下发现 float64 ，输出这个的原因是我要把一个 float64 的元素强行用 int 类型的占位符进行处理； 所以现在进一步清晰了，json.Unmarshal 函数会把 id 转为 float64； 那么问题又来了，为什么它会把 id 转为 float64 类型呢？id == 1 的时候为什么能正常输出呢？ 进源码，看看函数内部做了什么： func Unmarshal(data []byte, v any) error { // Check for well-formedness. // Avoids filling out half a data structure // before discovering a JSON syntax error. var d decodeState err := checkValid(data, \u0026amp;d.scan) if err != nil { return err } d.init(data) return d.unmarshal(v) } // 可以看到 checkValid() 方法引用了 decodeState 结构体 // 进结构体里看下： // decodeState represents the state while decoding a JSON value. type decodeState struct { data []byte off int // next read offset in data opcode int // last read result scan scanner errorContext *errorContext savedError error useNumber bool disallowUnknownFields bool } // 初步观察有个 bool 类型的 useNumber 属性 // 接着看下这个结构体具体的实现方法： // convertNumber converts the number literal s to a float64 or a Number // depending on the setting of d.useNumber. func (d *decodeState) convertNumber(s string) (any, error) { if d.useNumber { return Number(s), nil } f, err := strconv.ParseFloat(s, 64) if err != nil { return nil, \u0026amp;UnmarshalTypeError{Value: \"number \" + s, Type: reflect.TypeOf(0.0), Offset: int64(d.off)} } return f, nil } // 到这里大概能清楚，是这个方法把我的 id 转成了 float64，但是再转之前还有一层 if 会把原始值输出； // 接下来就回去上一级，看看 d.scan 到底做了什么： // 努力中... // ——————看不懂 经过多方查找： 理论上 json 会把超过 int64 长度的数字转成 float64，但是这个说法经实践不成立，毫秒级时间戳 13 位，远没有超过 int64 的最大长度； 多次翻阅资料后，有一个说法比较靠谱： 当处理非常大的整数（如毫秒级的时间戳）时，如果直接使用 Go 语言中的整数类型（如 int 或 int64），可能会因为超出这些类型的表示范围而导致溢出。虽然 int64 类型在大多数情况下可以容纳毫秒级的时间戳，但为了确保能够处理所有可能的 JSON 数字，encoding/json 包选择了 float64 类型作为默认解析结果。 到这里其实我们最初的目的也轻松处理： func main() { str := \"{\\\"id\\\":1736325205000,\\\"name\\\":\\\"张三\\\",\\\"age\\\":20}\" jsonMap := make(map[string]interface{}) json.Unmarshal([]byte(str), \u0026amp;jsonMap) // 断言类型为 float64 fmt.Println(jsonMap[\"id\"]) if f, ok := jsonMap[\"id\"].(float64); ok { fmt.Println(int(f)) } } // 输出 // 1736325205000 ","date":"2025-01-12","objectID":"/posts/json_unmarshall_parsing_numeric_types/:0:0","tags":["golang"],"title":"Json.Unmarshal 解析数字类型（踩坑）","uri":"/posts/json_unmarshall_parsing_numeric_types/"},{"categories":["golang"],"content":"高效地处理多个数据源并将其整合为有意义的结果是开发中一项重要的任务。Go 语言，以其强大的并发特性，为我们提供了优雅而高效的解决方案。那么我们探讨一下如何利用 Go 语言的协程，同时调用多个接口获取数据，并将这些数据无缝地合并为一个完整的数据集。 先假定一个场景：现有一需求，需要请求n个接口（暂定为3个）获取接口数据，然后对数据进行二次处理并返回。 按照过往的经验，我们会依次请求接口拿到数据暂存，最后对数据进行包装处理，这种自上而下的处理方式其实并无不妥，现在想要提高下效率，利用牺牲cpu资源来换取查询性能。 先模拟创建几个接口，分别返回(k1，v1)、(k2，v2)、(k3，v4)： // 模拟接口A func getDataFromA() map[string]interface{} { return map[string]interface{}{ \"key1\": \"value1\", } } // 模拟接口B func getDataFromB() map[string]interface{} { return map[string]interface{}{ \"key2\": \"value2\", } } // 模拟接口C func getDataFromC() map[string]interface{} { return map[string]interface{}{ \"key3\": \"value3\", } } 开启协程分别请求上述接口： 首先得思考一个问题，协程执行不保证顺序，请求到的数据应该怎么保存？怎么判断全部协程都执行完毕？怎么拿到全部的数据？ 上述接口定义中返回的数据均是map，那么我完全可以用map来保存数据，所以我定义方法就可以这么定义： func getAllData() map[string]interface{} { return nil // 暂时先不做处理 } 为了防止主协程先于其他执行结束，需要引入 sync.WaitGroup 包控制；所有协程返回的数据，可以用通道来暂存，make 一个容量为 3 的 Channel： func getAllData() map[string]interface{} { var wg sync.WaitGroup resultChan := make(chan map[string]interface{}, 3) return nil // 暂时先不做处理 } 接下来就可以开启协程去调用: func getAllData() map[string]interface{} { var wg sync.WaitGroup resultChan := make(chan map[string]interface{}, 3) wg.Add(3) go func() { defer wg.Done() resultChan \u003c- getDataFromA() }() go func() { defer wg.Done() resultChan \u003c- getDataFromB() }() go func() { defer wg.Done() resultChan \u003c- getDataFromC() }() wg.Wait() close(resultChan) return nil // 暂时先不做处理 } 最后可以对数据做个简单处理，封装成一个大map返回，实际业务当然按需处理： newMap := make(map[string]interface{}) for res := range resultChan { for k, v := range res { newMap [k] = v } } return newMap 执行验证返回结果： [Running] go run \"main.go\" map[key1:value1 key2:value2 key3:value3] ","date":"2025-01-12","objectID":"/posts/collaborative_processing_of_multiple_interfaces/:0:0","tags":["golang","并发","协程"],"title":"Go 语言并发实战：利用协程处理多个接口的 Map 数据融合","uri":"/posts/collaborative_processing_of_multiple_interfaces/"},{"categories":["golang"],"content":"在如今的编程领域，一个程序能够同时处理多个任务的能力非常重要，而 Golang 在并发编程方面表现十分出色，具有很多独特的优势。 ","date":"2025-01-12","objectID":"/posts/the_concurrency_advantage_of_go/:0:0","tags":["golang","并发"],"title":"Go 的并发优势","uri":"/posts/the_concurrency_advantage_of_go/"},{"categories":["golang"],"content":"一、轻量级的协程（Goroutine） 在传统的像 Java 这样的编程语言中，创建线程来实现并发往往需要较大的资源开销和复杂的管理。但在 Golang 里，有了 Goroutine 就截然不同。 Goroutine 的创建几乎不费力气，我们可以毫无压力地同时启动成千上万的 Goroutine 来完成不同的任务，而且不用担心资源被大量消耗。 举个例子： package main import ( \"fmt\" \"time\" ) func task() { fmt.Println(\"Hello Goroutine!\") } func main() { go task() time.Sleep(1 * time.Second) } 在这段代码里，我们用 go task() 轻松地启动了一个 Goroutine 去执行 task 函数。 当然这样可能更直观： package main import ( \"fmt\" \"time\" ) func main() { go func() { fmt.Println(\"Hello Goroutine!\") }() time.Sleep(1 * time.Second) } ","date":"2025-01-12","objectID":"/posts/the_concurrency_advantage_of_go/:1:0","tags":["golang","并发"],"title":"Go 的并发优势","uri":"/posts/the_concurrency_advantage_of_go/"},{"categories":["golang"],"content":"二、高效的通道（Channel） 在并发编程中，不同的任务之间需要数据通信。Golang 里的通道（Channel）就像是一个专门的管道，使得数据通信安全又高效。 package main import \"fmt\" func main() { ch := make(chan int) // 无缓冲的通道 go func() { ch \u003c- 1 }() num := \u003c-ch fmt.Println(num) } 通过这个通道 ch，我们成功地在两个不同的 Goroutine 之间传递了数据。 ","date":"2025-01-12","objectID":"/posts/the_concurrency_advantage_of_go/:2:0","tags":["golang","并发"],"title":"Go 的并发优势","uri":"/posts/the_concurrency_advantage_of_go/"},{"categories":["golang"],"content":"三、优秀的内存管理和并发调度 在编程语言中，内存管理和并发调度是影响程序性能和稳定性的关键因素。Golang 在这两个方面展现出了卓越的特性。 Golang 拥有一套自动且高效的内存回收机制。这意味着开发者无需像在 Java 等语言中那样，时刻关注内存的分配与释放，避免了因手动管理内存而可能导致的内存泄漏和野指针等问题。这种自动内存管理机制不仅减轻了开发者的负担，还提高了程序的可靠性和可维护性。 同时，Golang 的并发调度机制极具智能性。它能够根据系统的负载和各个 Goroutine 的状态，合理地分配 CPU 资源，确保每个 Goroutine 都能获得公平的执行机会。与 Java 等语言的线程调度相比，Golang 的调度更加轻量和灵活，能够在高并发场景下实现更高效的资源利用，从而显著提升程序的整体性能和响应速度。 ","date":"2025-01-12","objectID":"/posts/the_concurrency_advantage_of_go/:3:0","tags":["golang","并发"],"title":"Go 的并发优势","uri":"/posts/the_concurrency_advantage_of_go/"},{"categories":["golang"],"content":"四、简洁而强大的并发编程模型 Golang 的并发编程模型以其简洁性和强大的功能而备受赞誉。 与 Java 等语言中相对复杂的并发控制机制（如锁、条件变量等）不同，Golang 提供了一种更为直观和易于理解的方式来处理并发。Goroutine 和 Channel 的组合使用，使得并发任务的创建、通信和同步变得清晰明了。开发者可以轻松地创建多个并发执行的任务，并通过 Channel 安全、高效地进行数据交换和协调。 此外，Golang 的并发错误处理机制也更加简洁和有效。它能够帮助开发者更快速地定位和解决并发环境中可能出现的问题，减少了因并发导致的错误排查难度和时间成本。这种简洁而强大的并发编程模型，极大地提高了开发者的生产效率，使他们能够更加专注于业务逻辑的实现，而不必在复杂的并发控制细节上耗费过多精力。 ","date":"2025-01-12","objectID":"/posts/the_concurrency_advantage_of_go/:4:0","tags":["golang","并发"],"title":"Go 的并发优势","uri":"/posts/the_concurrency_advantage_of_go/"},{"categories":["golang"],"content":"下载Golang 官网链接：https://golang.google.cn/dl/ ","date":"2025-01-12","objectID":"/posts/golang_development_environment/:1:0","tags":["golang"],"title":"Golang 开发环境搭建","uri":"/posts/golang_development_environment/"},{"categories":["golang"],"content":"配置环境 安装好之后须添加如下环境变量： 变更名 变量值 说明 GOPATH E:\\gowork Go语言的工作目录，存放自己编写的 .go 文件、项目、包、编译的二进制文件等 GOROOT D:\\go1.18 Go的安装路径 开启go mod 及配置国内代理： go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct ","date":"2025-01-12","objectID":"/posts/golang_development_environment/:2:0","tags":["golang"],"title":"Golang 开发环境搭建","uri":"/posts/golang_development_environment/"},{"categories":["golang"],"content":"配置vscode 安装 Go、vscode-go-syntax 两插件 届时，vscode 会弹出需要安装其他 go 扩展的提示，只需要 Install All 即可 ","date":"2025-01-12","objectID":"/posts/golang_development_environment/:3:0","tags":["golang"],"title":"Golang 开发环境搭建","uri":"/posts/golang_development_environment/"},{"categories":null,"content":"关于我 一名后端工程师，会点 Java 会点 Golang 偶尔也玩 Python。 工作三年有余，做过金融，也做过CRM，目前在某一线大厂工作。 感兴趣的事，就爱折腾到底，为了那一丝成就感，哪怕微不足道。 ","date":"2025-01-12","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于博客 2018 - 2019：大学初始，开启了编程生涯，白天上课，晚上 bilibili，后来认识到了 遇见狂胜说 ，从而开启了博客之路。 2019 - 2020：在 博客园 注册自己的第一个博客，发表了几篇随笔，收获不少访问量，心中大喜。 2020 - 2021：由于实在接受不了博客园充斥着满满复古味道的 UI ，期间自己不断的网上找美化教程，始终不敬我意，而后转战 CSDN 。 2021 - 2024：长期混迹在 CSDN ，期间也发表些许文章，收获众多点赞收藏，文章也被多次转载，曾经也上过周榜Top 5。 2025 年 1 月：因为 CSDN 吃相实在太难看（广告不断，机器人太多，抄袭严重），辗转反侧，决定注销账号，重头再来，于是开启了 Github Page 打造属于自己的一亩三分地。 2026 年 ：未来继续折腾…… …… 免责声明 欢迎访问本个人站点。但请注意，您在本站发表的任何评论都将被记录并保存。为保护您的个人隐私及遵守法律法规，请勿张贴任何涉及个人隐私的信息。同时，您在发表言论时，请务必遵守中华人民共和国及其它国家和地区的相关法律法规，以避免承担不必要的法律责任。 本站点可能包含引用、摘录或转载自第三方的文字、图片、视频等内容。这些第三方内容的引用旨在传递更多信息，而非代表本站赞同其观点或认可其真实性。对于上述第三方内容的准确性、安全性和完整性，本站不作任何保证或承诺。 在阅读、下载及使用本站点提供的内容时，请您自行判断并承担相应风险。如因使用本站内容导致您或您的网站遭受任何形式的损失或伤害，本站不承担任何责任。 版权声明 除特殊声明外，本站遵循 CC BY-NC 4.0 协议,允许您自由分享与演绎，但请务必遵守以下原则： 署名与出处：分享或演绎时，请明确注明原始内容的作者及来源，以示尊重版权。 非商业使用：所有使用、分享或演绎均限于非商业目的，不得用于盈利活动。 相同条件共享：确保其他用户能在相同条件下访问和使用您分享或演绎的内容。 ","date":"2025-01-12","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"正在建设中… ","date":"2025-01-12","objectID":"/link/:0:0","tags":null,"title":"友链","uri":"/link/"}]