[{"categories":["golang"],"content":"在Go语言 json 处理领域，在 json 数据处理中，读取与修改是两个核心需求。前文介绍的 GJSON 解决了灵活读取问题，而 SJSON 作为其姊妹库，则专注于实现无需结构体定义的 json 动态修改。 本文将延续对比分析风格，解析 SJSON 的核心价值。 ","date":"2025-03-09","objectID":"/posts/go_sjson_component/:0:0","tags":["golang"],"title":"Go-SJSON 组件，JSON 动态修改新方案","uri":"/posts/go_sjson_component/"},{"categories":["golang"],"content":"一、Go 原生 json 修改方式 Go 原生修改 json 数据，同样需先定义结构体，然后再将 json 数据解析到结构体实例，如： package main import ( \"encoding/json\" \"fmt\" ) type Person struct { Name string `json:\"name\"` Age int `json:\"age\"` } func main() { jsonStr := `{\"name\":\"张三\",\"age\":25}` var person Person err := json.Unmarshal([]byte(jsonStr), \u0026person) if err != nil { fmt.Println(\"解析错误:\", err) return } person.Age = 35 newJson, _ := json.Marshal(person) fmt.Println(string(newJson)) } ","date":"2025-03-09","objectID":"/posts/go_sjson_component/:1:0","tags":["golang"],"title":"Go-SJSON 组件，JSON 动态修改新方案","uri":"/posts/go_sjson_component/"},{"categories":["golang"],"content":"二、SJSON 组件 ","date":"2025-03-09","objectID":"/posts/go_sjson_component/:2:0","tags":["golang"],"title":"Go-SJSON 组件，JSON 动态修改新方案","uri":"/posts/go_sjson_component/"},{"categories":["golang"],"content":"1、概述： SJSON 提供通过路径表达式直接修改 json 字符串的能力，与 GJSON 采用相同路径语法，形成读写闭环。 官网地址：GitHub - tidwall/sjson ","date":"2025-03-09","objectID":"/posts/go_sjson_component/:2:1","tags":["golang"],"title":"Go-SJSON 组件，JSON 动态修改新方案","uri":"/posts/go_sjson_component/"},{"categories":["golang"],"content":"2、安装： 使用 Go 的包管理工具 go get 安装 SJSON： go get -u github.com/tidwall/sjson ","date":"2025-03-09","objectID":"/posts/go_sjson_component/:2:2","tags":["golang"],"title":"Go-SJSON 组件，JSON 动态修改新方案","uri":"/posts/go_sjson_component/"},{"categories":["golang"],"content":"三、SJSON核心用法 ","date":"2025-03-09","objectID":"/posts/go_sjson_component/:3:0","tags":["golang"],"title":"Go-SJSON 组件，JSON 动态修改新方案","uri":"/posts/go_sjson_component/"},{"categories":["golang"],"content":"1、基础值修改 package main import ( \"fmt\" \"github.com/tidwall/sjson\" ) func main() { jsonStr := `{\"name\":\"张三\",\"age\":25}` // 修改 age 值为 35 newJson, _ := sjson.Set(jsonStr, \"age\", 35) fmt.Println(string(newJson)) } ","date":"2025-03-09","objectID":"/posts/go_sjson_component/:3:1","tags":["golang"],"title":"Go-SJSON 组件，JSON 动态修改新方案","uri":"/posts/go_sjson_component/"},{"categories":["golang"],"content":"2、嵌套结构修改 package main import ( \"fmt\" \"github.com/tidwall/sjson\" ) func main() { jsonStr := `{ \"name\": \"张三\", \"age\": 25, \"hobby\": { \"sing\": \"只因你太美\", \"dance\": \"背带裤\", \"rap\": \"kun\", \"ball\": \"篮球\" }` // 修改 hobby.sing 的值: 只因你太美 =\u003e 重生 newJson, _ := sjson.Set(jsonStr, \"hobby.sing\", \"重生\") fmt.Println(string(newJson)) } ","date":"2025-03-09","objectID":"/posts/go_sjson_component/:3:2","tags":["golang"],"title":"Go-SJSON 组件，JSON 动态修改新方案","uri":"/posts/go_sjson_component/"},{"categories":["golang"],"content":"3、数组操作 package main import ( \"fmt\" \"github.com/tidwall/sjson\" ) func main() { jsonStr := `{\"hobby\": [\"sing\",\"dance\",\"rap\",\"ball\"]}` // 修改 hobby 数组第4个元素为 play newJson, _ := sjson.Set(jsonStr, \"hobby.3\", \"play\") fmt.Println(string(newJson)) // 追加 hobby 数组第5个元素为 play newJson, _ = sjson.Set(jsonStr, \"tags.-1\", \"play\") fmt.Println(string(newJson)) } ","date":"2025-03-09","objectID":"/posts/go_sjson_component/:3:3","tags":["golang"],"title":"Go-SJSON 组件，JSON 动态修改新方案","uri":"/posts/go_sjson_component/"},{"categories":["golang"],"content":"4、字段删除 package main import ( \"fmt\" \"github.com/tidwall/sjson\" ) func main() { jsonStr := `{\"name\":\"张三\",\"age\":25}` // 删除age字段 newJson, _ := sjson.Delete(jsonStr, \"age\") fmt.Println(string(newJson)) } ","date":"2025-03-09","objectID":"/posts/go_sjson_component/:3:4","tags":["golang"],"title":"Go-SJSON 组件，JSON 动态修改新方案","uri":"/posts/go_sjson_component/"},{"categories":["golang"],"content":"四、SJSON 与原生方案对比 SJSON 摆脱结构体定义束缚，保持原始 json 结构完整性，避免修改后丢失未定义字段的问题。 SJSON 路径直达修改位置，规避嵌套结构嵌套带来的问题，与 GJSON 组成完整处理链路。 SJSON 支持运行时动态路径构建，避免硬编码路径带来的问题。 ","date":"2025-03-09","objectID":"/posts/go_sjson_component/:4:0","tags":["golang"],"title":"Go-SJSON 组件，JSON 动态修改新方案","uri":"/posts/go_sjson_component/"},{"categories":["golang"],"content":"在 Go 语言开发领域，json 数据处理是极为常见的任务。Go 标准库提供了 encoding/json 包用于处理 json 数据，同时第三方库 GJSON \u0026 SJSON 也在 json 处理方面表现出色。 本文先深入探讨下 GJSON 组件，通过与原生处理方式对比，它存在什么特别之处，它的优势体现在哪。 ","date":"2025-03-02","objectID":"/posts/go_gjson_component/:0:0","tags":["golang"],"title":"Go-GJSON 组件，解锁 JSON 读取新姿势","uri":"/posts/go_gjson_component/"},{"categories":["golang"],"content":"一、Go 原生 json 读取方式 Go 原生读取 json 数据，通常需先定义结构体，然后再将 json 数据解析到结构体实例，如： { \"name\": \"张三\", \"age\": 25 } 具体处理逻辑： package main import ( \"encoding/json\" \"fmt\" ) type Person struct { Name string `json:\"name\"` Age int `json:\"age\"` } func main() { jsonStr := `{\"name\":\"张三\",\"age\":25}` var person Person err := json.Unmarshal([]byte(jsonStr), \u0026person) if err!= nil { fmt.Println(\"解析错误:\", err) return } fmt.Println(\"Name:\", person.Name) fmt.Println(\"Age:\", person.Age) } 这种方式虽能准确解析 json 数据，但如果 json 存在多层嵌套，层级过度包装，那么结构体定义以及解析过程就会变得相当繁琐。 ","date":"2025-03-02","objectID":"/posts/go_gjson_component/:1:0","tags":["golang"],"title":"Go-GJSON 组件，解锁 JSON 读取新姿势","uri":"/posts/go_gjson_component/"},{"categories":["golang"],"content":"二、GJSON 组件 ","date":"2025-03-02","objectID":"/posts/go_gjson_component/:2:0","tags":["golang"],"title":"Go-GJSON 组件，解锁 JSON 读取新姿势","uri":"/posts/go_gjson_component/"},{"categories":["golang"],"content":"1、概述： GJSON 是一个轻量级且高性能的 JSON 解析库，它允许开发者通过简洁的语法，无需定义结构体，就能快速提取 JSON 数据中的特定值。 官网地址：GitHub - tidwall/gjson ","date":"2025-03-02","objectID":"/posts/go_gjson_component/:2:1","tags":["golang"],"title":"Go-GJSON 组件，解锁 JSON 读取新姿势","uri":"/posts/go_gjson_component/"},{"categories":["golang"],"content":"2、安装： 使用 Go 的包管理工具 go get 安装 GJSON： go get -u github.com/tidwall/gjson ","date":"2025-03-02","objectID":"/posts/go_gjson_component/:2:2","tags":["golang"],"title":"Go-GJSON 组件，解锁 JSON 读取新姿势","uri":"/posts/go_gjson_component/"},{"categories":["golang"],"content":"三、GJSON 基本用法 ","date":"2025-03-02","objectID":"/posts/go_gjson_component/:3:0","tags":["golang"],"title":"Go-GJSON 组件，解锁 JSON 读取新姿势","uri":"/posts/go_gjson_component/"},{"categories":["golang"],"content":"1、简单 json 数据获取 对于简单的 json，像前面那个例子，直接用 gjson.Get 方法，传入 json 字符串和要获取的字段名，就能拿到对应的值。比如获取 name 字段，gjson.Get(jsonStr, \"name\") 就可以搞定，例如： package main import ( \"fmt\" \"github.com/tidwall/gjson\" ) func main() { jsonStr := `{\"name\":\"张三\",\"age\":25}` name := gjson.Get(jsonStr, \"name\") age := gjson.Get(jsonStr, \"age\") fmt.Println(\"Name:\", name.String()) fmt.Println(\"Age:\", age.Int()) } ","date":"2025-03-02","objectID":"/posts/go_gjson_component/:3:1","tags":["golang"],"title":"Go-GJSON 组件，解锁 JSON 读取新姿势","uri":"/posts/go_gjson_component/"},{"categories":["golang"],"content":"2、嵌套 json 数据获取 上述提到，原生的处理方式对于多层级的 json 很不友好，然而 gjon 可以直接通过点号分隔路径定位数据，这时候它的优势就逐渐明显，例如： { \"name\": \"张三\", \"age\": 25, \"hobby\": { \"sing\": \"只因你太美\", \"dance\": \"背带裤\", \"rap\": \"kun\", \"ball\": \"篮球\" } } 具体处理逻辑： package main import ( \"fmt\" \"github.com/tidwall/gjson\" ) func main() { jsonStr := `{ \"name\": \"张三\", \"age\": 25, \"hobby\": { \"sing\": \"只因你太美\", \"dance\": \"背带裤\", \"rap\": \"kun\", \"ball\": \"篮球\" }` name := gjson.Get(jsonStr, \"name\") ball := gjson.Get(jsonStr, \"hobby.ball\") fmt.Println(\"Name:\", name.String()) fmt.Println(\"ball:\", ball.String()) } 相比原生方式，无需复杂结构体定义，操作更简便。 ","date":"2025-03-02","objectID":"/posts/go_gjson_component/:3:2","tags":["golang"],"title":"Go-GJSON 组件，解锁 JSON 读取新姿势","uri":"/posts/go_gjson_component/"},{"categories":["golang"],"content":"3、json 数组处理 如果在 json 中嵌套了数组，对于这种的处理也比较简单，直接通过数组下标来定位数据即可，如： package main import ( \"fmt\" \"github.com/tidwall/gjson\" ) func main() { jsonStr := `{\"hobby\": [\"sing\",\"dance\",\"rap\",\"ball\"]}` hobby := gjson.Get(jsonStr, \"hobby.3\") // 输出第4个爱好 fmt.Println(\"hobby:\", hobby.String()) } 相比于原生方式处理数组，得先解析成切片，操作起来就没这么直接。 ","date":"2025-03-02","objectID":"/posts/go_gjson_component/:3:3","tags":["golang"],"title":"Go-GJSON 组件，解锁 JSON 读取新姿势","uri":"/posts/go_gjson_component/"},{"categories":["golang"],"content":"四、GJSON 与原生 JSON 处理方式对比 GJSON 语法简单直观，熟悉 json 结构即可快速上手，无需学习结构体定义及标签使用等知识。而原生方式在结构体定义上相对复杂，尤其是处理复杂 json 结构时。 GJSON 无需将整个 json 数据解析为结构体，在处理大型 json 数据时，内存占用少，解析速度快。原生方式在解析复杂 json 数据时，结构体构建和内存分配开销较大。 GJSON 对各种复杂 json 结构都能灵活应对，根据需求按路径获取数据，无需频繁修改代码结构。原生方式则需根据 json 结构变化，频繁修改结构体定义，灵活性较差。 ","date":"2025-03-02","objectID":"/posts/go_gjson_component/:4:0","tags":["golang"],"title":"Go-GJSON 组件，解锁 JSON 读取新姿势","uri":"/posts/go_gjson_component/"},{"categories":["其他"],"content":" 最近 AI 大模型的热度可谓是如火如荼，尤其是国内的 DeepSeek 名闻遐迩，因其与 OpenAI 的模型相比，DeepSeek 推理大模型 R1 的训练成本仅为其 3%-5%‌ ，直接导致英伟达公司股票短时间内大跌。 此时我就比较好奇，为什么大模型训练中更多的是依赖 GPU，而不是 CPU 呢？ 随后这两天网上翻阅了些资料，也询问 AI 帮忙解答，大体总结出如下几点： 一、并行计算能力 GPU 具有高度并行的架构，能够同时处理大量的数据和计算任务。比如在进行矩阵运算时，它可以同时对多个元素进行操作，瞬间完成复杂的计算。 相比之下，CPU 虽然在串行计算方面表现不错，但并行处理能力相对较弱，无法像 GPU 那样同时处理众多任务。 二、内存带宽 大模型训练需要处理的数据量巨大，比如 DeepSeek R1 满血版参数就高达 671B （6710亿）这对内存带宽要求极高。 GPU 配备了超高的内存带宽，就类似拥有一条宽阔的高速公路，数据可以快速地传输到计算核心进行处理。 而 CPU 的内存带宽则相对有限，面对海量数据时，就像走在狭窄的小道上，容易形成数据传输的瓶颈，拖慢训练速度。 三、浮点运算性能 在大模型训练中，离不开浮点运算。 GPU 在浮点运算性能方面优势明显，它拥有大量的浮点运算单元，能够在单位时间内执行海量的浮点运算操作。 CPU 的浮点运算能力相对较弱，在处理大规模的浮点运算时，效率远远比不上 GPU 。 四、深度学习框架支持 现在主流的深度学习框架，像是 TensorFlow 和 PyTorch 等，都对 GPU 进行了深度优化和兼容，能够充分发挥其强大的性能，自动将计算任务合理分配到 GPU 上并行执行。 然而，对于 CPU 的优化就没那么给力，导致在实际训练中，使用 CPU 的效果不尽如人意。 五、能耗效率 常理来看 GPU 功耗好像挺高，但从单位时间完成的计算量来看，它的能耗效率还是可以的。 虽然 CPU 功耗低，但完成相同的训练任务需要更长时间，综合能耗并不占优势。 六、成本效益 GPU 单价相比 CPU 确实较高，但是它能大幅缩短训练时间。有句话说的好，时间就是金钱！这样算下来，总体的成本反而更低。 而 CPU 训练时间长，资源占用和维护成本累加起来也不少。 所以，综合以上这些方面看，GPU 在大模型训练中脱颖而出，而 CPU 则在这个领域就有点力不从心了。 ","date":"2025-02-15","objectID":"/posts/why_does_ai_training_rely_on_gpus_instead_of_cpus/:0:0","tags":["AI"],"title":"为什么大模型训练依赖 GPU 而不是 CPU","uri":"/posts/why_does_ai_training_rely_on_gpus_instead_of_cpus/"},{"categories":["golang"],"content":"在 Go 项目开发中，有效的异常处理是确保程序健壮性和稳定性的关键因素之一。全局异常处理机制能够统一处理项目中可能出现的各种异常情况，提高代码的可读性、可维护性以及错误处理的一致性。 ","date":"2025-02-09","objectID":"/posts/go_practical_global_exception_handling/:0:0","tags":["golang","gin","panic"],"title":"Go 项目实战：全局异常处理","uri":"/posts/go_practical_global_exception_handling/"},{"categories":["golang"],"content":"一、Go 中的错误处理机制 在 Go 语言中，并没有像其他语言那样的传统异常机制。而是期望开发者主动去识别处理这种“异常”，通过返回值来表示可能出现的错误。 通常情况下，函数会返回一个结果集和一个错误值，我们需要判断错误值是否为 nil，如果不为 nil 则表示出现了“异常”。 package main import ( \"fmt\" ) // 模拟一个会返回错误的函数 func divide(a, b int) (int, error) { if b == 0 { return 0, fmt.Errorf(\"除数不能为 0\") } return a / b, nil } func main() { result, err := divide(10, 0) if err != nil { fmt.Println(\"出错啦:\", err) return } fmt.Println(\"结果是:\", result) } ","date":"2025-02-09","objectID":"/posts/go_practical_global_exception_handling/:1:0","tags":["golang","gin","panic"],"title":"Go 项目实战：全局异常处理","uri":"/posts/go_practical_global_exception_handling/"},{"categories":["golang"],"content":"二、Go 中的 panic 当程序遇到无法处理的错误时，就会被提示panic，程序会直接崩溃。 recover 函数用于捕获 panic 抛出的信息，让程序从 panic 状态恢复继续正常执行，前提 recover 只能在 defer 函数中使用。 package main import ( \"fmt\" ) func main() { defer func() { if r := recover(); r != nil { fmt.Println(\"已捕获到恐慌:\", r) } }() // 手动触发一个 panic panic(\"这是一个恐慌！\") } // 输出： // 已捕获到恐慌:这是一个恐慌！ ","date":"2025-02-09","objectID":"/posts/go_practical_global_exception_handling/:2:0","tags":["golang","gin","panic"],"title":"Go 项目实战：全局异常处理","uri":"/posts/go_practical_global_exception_handling/"},{"categories":["golang"],"content":"三、实现全局异常处理 根据上述其实不难发现，错误处理是显式的，我们可以做前置判断，根据具体情况进行处理，但是panic 处理通常是隐式的，一旦被调用 panic 函数，程序的执行流程会被打乱，需捕获 panic 才能恢复程序的正常执行。 所以针对这种隐式的、在编程过程中无法提前预知的错误，就很有必要做一层异常的处理，最好可以是全局处理。 为了实现全局异常处理，我们可以创建一个中间件或者全局的异常处理函数。 func GlobalErrorHandler() gin.HandlerFunc { return func(c *gin.Context) { defer func() { if err := recover(); err!= nil { log.Printf(\"Recovered from panic: %v\", err) c.JSON(500, gin.H{ \"message\": \"Internal Server Error\", }) c.Abort() } }() c.Next() } } ","date":"2025-02-09","objectID":"/posts/go_practical_global_exception_handling/:3:0","tags":["golang","gin","panic"],"title":"Go 项目实战：全局异常处理","uri":"/posts/go_practical_global_exception_handling/"},{"categories":["golang"],"content":"四、在项目中的应用 在实际的项目中，我们可以将这个全局异常处理中间件应用到 HTTP 服务器的路由处理中。 package main import ( \"github.com/gin-gonic/gin\" \"log\" ) func main() { r := gin.Default() // 应用全局异常处理中间件 r.Use(GlobalErrorHandler()) r.GET(\"/ping\", func(c *gin.Context) { // 模拟异常 panic(\"Something went wrong!\") }) r.Run(\":8080\") } 这样下来，在程序的后续处理中，一旦遇到 panic 就会被捕获，从而不影响程序的继续运行。 ","date":"2025-02-09","objectID":"/posts/go_practical_global_exception_handling/:4:0","tags":["golang","gin","panic"],"title":"Go 项目实战：全局异常处理","uri":"/posts/go_practical_global_exception_handling/"},{"categories":["golang"],"content":"在 Go 项目的开发过程中，能够在不同的环境（如开发、测试、生产）中进行灵活部署是至关重要的。不同环境通常需要不同的配置，如服务器端口、数据库连接信息、缓存设置等。 对于 Java 的 SpringBoot 框架来说，可以直接在 application.yml 中指定一个环境配置文件，通常application_dev.yml 代表开发环境，那么 go 可否参考这种方式呢？ 接下来本文将详细介绍如何使用多种方式来实现多环境开发部署，重点围绕 config.yaml 文件和 config.go 文件来进行配置读取和环境区分。 ","date":"2025-01-25","objectID":"/posts/go_practical_multi_environment_development/:0:0","tags":["golang","gin"],"title":"Go 项目实战：如何部署多环境开发","uri":"/posts/go_practical_multi_environment_development/"},{"categories":["golang"],"content":"Go 中的系统环境变量 先来解释一个概念，在 Go 语言中，系统环境变量是操作系统为每个进程提供的键值对集合。这些环境变量可以用于配置应用程序的行为、连接数据库、设置日志级别等。Go 提供了标准库 os 来读取和操作这些环境变量。 ","date":"2025-01-25","objectID":"/posts/go_practical_multi_environment_development/:1:0","tags":["golang","gin"],"title":"Go 项目实战：如何部署多环境开发","uri":"/posts/go_practical_multi_environment_development/"},{"categories":["golang"],"content":"实战 ","date":"2025-01-25","objectID":"/posts/go_practical_multi_environment_development/:2:0","tags":["golang","gin"],"title":"Go 项目实战：如何部署多环境开发","uri":"/posts/go_practical_multi_environment_development/"},{"categories":["golang"],"content":"1、编写.env文件 在项目根目录下新建一个 .env 文件，配置如下： APP_ENV=dev ","date":"2025-01-25","objectID":"/posts/go_practical_multi_environment_development/:2:1","tags":["golang","gin"],"title":"Go 项目实战：如何部署多环境开发","uri":"/posts/go_practical_multi_environment_development/"},{"categories":["golang"],"content":"2、获取环境变量 使用 os.Getenv 函数可以获取指定名称的环境变量值。 env := os.Getenv(\"APP_ENV\") APP_ENV 是一个环境变量名，用于标识应用程序的运行环境（如开发、测试、生产等）。 如果 APP_ENV 未设置，os.Getenv(\"APP_ENV\") 将返回空字符串。 ","date":"2025-01-25","objectID":"/posts/go_practical_multi_environment_development/:2:2","tags":["golang","gin"],"title":"Go 项目实战：如何部署多环境开发","uri":"/posts/go_practical_multi_environment_development/"},{"categories":["golang"],"content":"3、设置默认值 我们需要一个默认的环境，如果 APP_ENV 未设置，将其设为 \"dev\"： env := os.Getenv(\"APP_ENV\") if env == \"\" { env = \"dev\" // 默认环境为 dev } 这样可以确保即使没有显式设置 APP_ENV，程序也能有一个合理的默认行为。 ","date":"2025-01-25","objectID":"/posts/go_practical_multi_environment_development/:2:3","tags":["golang","gin"],"title":"Go 项目实战：如何部署多环境开发","uri":"/posts/go_practical_multi_environment_development/"},{"categories":["golang"],"content":"4、加载 .env 文件 使用 github.com/joho/godotenv 包来加载 .env 文件中的环境变量。.env 文件通常用于本地开发环境，避免将敏感信息硬编码到代码中，这里其实挺像 vue 的环境加载方式。 err := godotenv.Load() if err != nil { return fmt.Errorf(\"加载 .env 文件失败: %v\", err) } 这行代码会读取项目根目录下的 .env 文件，并将其中定义的环境变量加载到当前进程中。 ","date":"2025-01-25","objectID":"/posts/go_practical_multi_environment_development/:2:4","tags":["golang","gin"],"title":"Go 项目实战：如何部署多环境开发","uri":"/posts/go_practical_multi_environment_development/"},{"categories":["golang"],"content":"5、动态选择配置文件 根据 APP_ENV 的值，动态选择不同的配置文件： viper.AddConfigPath(\"./config\") viper.SetConfigName(fmt.Sprintf(\"config_%s\", env)) viper.SetConfigType(\"yaml\") 这段代码会根据 APP_ENV 的值（例如 dev 或 production），选择对应的配置文件（如 config_dev.yaml 或 config_prod.yaml）。这样可以根据不同的环境加载不同的配置。 ","date":"2025-01-25","objectID":"/posts/go_practical_multi_environment_development/:2:5","tags":["golang","gin"],"title":"Go 项目实战：如何部署多环境开发","uri":"/posts/go_practical_multi_environment_development/"},{"categories":["golang"],"content":"6、解析配置文件 使用 viper.Unmarshal 将配置文件的内容解析到结构体中： Conf = \u0026Config{} err = viper.Unmarshal(Conf) if err != nil { return fmt.Errorf(\"解析配置文件失败: %v\", err) } viper.Unmarshal 会将配置文件中的键值对映射到结构体字段上，前提是结构体字段标签（如 yaml 和 mapstructure）与配置文件中的键匹配。 通过上述方式，我们可以根据项目的实际需求和情况，确保项目在不同环境下都能正确配置并稳定运行。 ","date":"2025-01-25","objectID":"/posts/go_practical_multi_environment_development/:2:6","tags":["golang","gin"],"title":"Go 项目实战：如何部署多环境开发","uri":"/posts/go_practical_multi_environment_development/"},{"categories":["golang"],"content":"在 Go 项目开发中，日志处理是一项至关重要的任务。它不仅有助于我们在开发过程中调试代码，还能在生产环境中帮助我们快速定位问题。本文将详细介绍如何在 Go 项目中优雅地处理日志，包括日志的级别、格式、输出以及如何使用第三方日志库等方面。 ","date":"2025-01-22","objectID":"/posts/go_practical_processing_log/:0:0","tags":["golang","gin"],"title":"Go 项目实战：如何优雅的处理日志","uri":"/posts/go_practical_processing_log/"},{"categories":["golang"],"content":"一、日志级别的重要性 日志级别是控制日志输出的重要手段。通过设置不同的日志级别，我们可以灵活地控制日志的详细程度。在 Go 语言中，常见的日志级别有DEBUG、INFO、WARN、ERROR和FATAL。不同级别的日志用于记录不同类型的信息，例如： DEBUG：用于记录详细的调试信息，仅在开发环境中启用。 INFO：用于记录正常的业务流程信息，例如请求的处理、数据的加载等。 WARN：用于记录可能存在的问题或异常情况，但不影响系统的正常运行。 ERROR：用于记录严重的错误信息，这些错误可能导致系统无法正常运行。 FATAL：用于记录非常严重的错误信息，这些错误会导致程序立即退出。 ","date":"2025-01-22","objectID":"/posts/go_practical_processing_log/:1:0","tags":["golang","gin"],"title":"Go 项目实战：如何优雅的处理日志","uri":"/posts/go_practical_processing_log/"},{"categories":["golang"],"content":"二、日志格式的选择 日志格式的选择对于日志的可读性和分析性至关重要。一个好的日志格式应该包含足够的信息，以便我们能够快速定位问题。常见的日志格式有 JSON、XML 和文本格式等。 在 Go 语言中，我们可以使用第三方库来实现不同的日志格式。例如，使用 logrus 库可以轻松地将日志格式化为 JSON 格式： package main import ( \"github.com/sirupsen/logrus\" ) func main() { // 设置日志格式为JSON logrus.SetFormatter(\u0026logrus.JSONFormatter{}) // 记录不同级别的日志 logrus.Debug(\"这是一条DEBUG级别的日志\") logrus.Info(\"这是一条INFO级别的日志\") logrus.Warn(\"这是一条WARN级别的日志\") logrus.Error(\"这是一条ERROR级别的日志\") logrus.Fatal(\"这是一条FATAL级别的日志\") } ","date":"2025-01-22","objectID":"/posts/go_practical_processing_log/:2:0","tags":["golang","gin"],"title":"Go 项目实战：如何优雅的处理日志","uri":"/posts/go_practical_processing_log/"},{"categories":["golang"],"content":"三、日志输出的方式 日志输出的方式有很多种，例如输出到控制台、文件、数据库等。在 Go 语言中，我们可以使用标准库的log包来实现基本的日志输出功能。例如，使用标准库 log.Println 方法可以将日志输出到控制台： package main import \"log\" func main() { // 记录日志到控制台 log.Println(\"这是一条日志信息\") } 如果需要将日志输出到文件，我们可以这么做： package main import ( \"log\" \"os\" ) func main() { // 创建日志文件 file, err := os.OpenFile(\"app.log\", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644) if err != nil { log.Fatal(err) } defer file.Close() // 设置日志输出到文件 log.SetOutput(file) // 记录日志 log.Println(\"这是一条日志信息\") } 除了常见的输出到控制台或指定文件，我们还可以将日志输出到数据库、Elasticsearch 等其他存储介质中。具体的实现方式还需根据实际需求进行选择。 ","date":"2025-01-22","objectID":"/posts/go_practical_processing_log/:3:0","tags":["golang","gin"],"title":"Go 项目实战：如何优雅的处理日志","uri":"/posts/go_practical_processing_log/"},{"categories":["golang"],"content":"四、使用第三方日志库 虽然说 Go 语言的标准库提供了基本的日志处理功能，但在实际项目中，往往需要结合第三方更为强大的库来满足日常需求： logrus：一个功能强大的日志库，支持多种日志格式、日志级别、日志输出方式等。 zap：一个高性能的日志库，具有快速、灵活、可扩展等特点。 zerolog：一个极简主义的日志库，专注于提供高性能和简单的 API。 ps: 上述简介来自于AI，注意甄别 这些第三方日志库都提供了丰富的功能和灵活的配置选项，可以帮助我们更好地处理日志。在这里个人比较推荐 logrus ，不过具体需求还是得具体选择。 ","date":"2025-01-22","objectID":"/posts/go_practical_processing_log/:4:0","tags":["golang","gin"],"title":"Go 项目实战：如何优雅的处理日志","uri":"/posts/go_practical_processing_log/"},{"categories":["golang"],"content":"五、实战 介绍再多也是空谈，接下来结合具体的项目，我们优雅的配置一下。 默认项目已经安装 logrus ，没有的话可以执行下如下命令： go get github.com/sirupsen/logrus ","date":"2025-01-22","objectID":"/posts/go_practical_processing_log/:5:0","tags":["golang","gin"],"title":"Go 项目实战：如何优雅的处理日志","uri":"/posts/go_practical_processing_log/"},{"categories":["golang"],"content":"1、配置config.yaml 为了方便随时更改切换 log 级别或者输出格式，我们可以单独抽离出来实现配置化： log: format: json # 输出格式 level: debug # 日志级别 report_caller: true # 是否开启调试 ","date":"2025-01-22","objectID":"/posts/go_practical_processing_log/:5:1","tags":["golang","gin"],"title":"Go 项目实战：如何优雅的处理日志","uri":"/posts/go_practical_processing_log/"},{"categories":["golang"],"content":"2、配置config.go 有了参数配置，还缺一步解析： 具体的解析可以参考 Go 项目实战：搭建高效的 Gin Web 目录结构 ","date":"2025-01-22","objectID":"/posts/go_practical_processing_log/:5:2","tags":["golang","gin"],"title":"Go 项目实战：如何优雅的处理日志","uri":"/posts/go_practical_processing_log/"},{"categories":["golang"],"content":"3、新建logger.go 在这里我们统一配置 logrus 参数，包括日志级别，输出格式： package app import ( log \"github.com/sirupsen/logrus\" ) // InitializeLogger 设置日志输出 func InitializeLogger() error { // 设置日志格式 switch config.Conf.Log.Format { case \"json\": log.SetFormatter(\u0026log.JSONFormatter{}) case \"text\": log.SetFormatter(\u0026log.TextFormatter{}) default: log.SetFormatter(\u0026log.JSONFormatter{}) } // 设置日志级别 switch config.Conf.Log.Level { case \"debug\": log.SetLevel(log.DebugLevel) case \"info\": log.SetLevel(log.InfoLevel) case \"warn\": log.SetLevel(log.WarnLevel) case \"error\": log.SetLevel(log.ErrorLevel) case \"fatal\": log.SetLevel(log.FatalLevel) case \"panic\": log.SetLevel(log.PanicLevel) default: log.SetLevel(log.InfoLevel) } // 设置打印调用信息 log.SetReportCaller(config.Conf.Log.ReportCaller) return nil } ","date":"2025-01-22","objectID":"/posts/go_practical_processing_log/:5:3","tags":["golang","gin"],"title":"Go 项目实战：如何优雅的处理日志","uri":"/posts/go_practical_processing_log/"},{"categories":["golang"],"content":"4、输出日志到文件 控制台打印日志，肯定是不满足一个项目的正常使用的，我们非常有必要将日志持久化到一个单独文件中。 但是这样还不够，会存在另一个问题：日志文件会越来越大后期不利于日志排查。所以还需要对日志进行一个分割，最好的实践方式就是按天分割，所以我们接着在上述初始化文件中去做设置： package app import ( \"os\" \"time\" \"github.com/lestrrat-go/file-rotatelogs\" log \"github.com/sirupsen/logrus\" \"your_project/config\" ) // InitializeLogger 设置日志输出并初始化日志文件 func InitializeLogger() error { // 设置日志格式 ... // 设置日志级别 ... // 设置打印调用信息 ... // 创建日志目录 logDir := \"../logs\" err := os.MkdirAll(logDir, 0755) if err != nil { log.Fatalf(\"创建日志目录失败: %v\", err) } // 设置日志输出，按天切割 logFilePath := logDir + \"/app.%Y%m%d.log\" writer, err := rotatelogs.New( logFilePath, rotatelogs.WithLinkName(logDir+\"/app.log\"), rotatelogs.WithMaxAge(7*24*time.Hour), // 保留7天 rotatelogs.WithRotationTime(24*time.Hour), // 每天切割一次 ) if err != nil { log.Fatalf(\"设置日志输出失败: %v\", err) } log.SetOutput(writer) return nil } ","date":"2025-01-22","objectID":"/posts/go_practical_processing_log/:5:4","tags":["golang","gin"],"title":"Go 项目实战：如何优雅的处理日志","uri":"/posts/go_practical_processing_log/"},{"categories":["golang"],"content":"5、调用InitializeLogger() package main import ( \"fmt\" \"github.com/gin-gonic/gin\" log \"github.com/sirupsen/logrus\" \"your_project/config\" \"your_project/internal/api/v1\" \"your_project/internal/app\" ) func main() { // 加载配置文件 err := config.LoadConfig() if err != nil { log.Error(\"配置文件加载错误: %v\", err) return } // 初始化 logger err = InitializeLogger() if err != nil { log.Error(\"logger 初始化错误: %v\", err) return } r := gin.Default() v1.SetupRoutes(r, Engine) err = r.Run(fmt.Sprintf(\":%d\", config.Conf.App.Port)) if err != nil { log.Error(\"服务启动错误: %v\", err) return } } 到这里一个完整的日志流程就算是配置好了。 ","date":"2025-01-22","objectID":"/posts/go_practical_processing_log/:5:5","tags":["golang","gin"],"title":"Go 项目实战：如何优雅的处理日志","uri":"/posts/go_practical_processing_log/"},{"categories":["golang"],"content":"引言 在当今迅速迭代的软件开发领域，挑选合适的工具与框架对于项目能否顺利推进至关重要。Gin 框架，作为 Go 语言生态中备受青睐的 Web 开发框架，凭借其卓越的性能、简洁的设计以及丰富的功能特性，在众多选项中脱颖而出。本文旨在深入剖析如何在使用 Gin 框架的过程中，构建一个既高效又便于管理的项目架构，助力开发者打造既快速响应又易于维护的 Web 应用程序。 ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:1:0","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"一、Gin 概述 引入官网的描述：Gin 是一个使用 Go 语言开发的 Web 框架。 它提供类似 Martini 的 API，但性能更佳，速度提升高达40倍。 如果你是性能和高效的追求者, 你会爱上 Gin。 对比 Beego 框架，Gin 框架采用了极简主义的方法，为追求简单和高性能，没有多余文件或目录，他甚至什么也没有，没有集成任何中间件，一个 main 文件即可启动一个web服务。 正因为如上所述，过分精简对于开发一个项目来说，前期的项目搭建工作就显得尤为重要。 ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:2:0","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"二、项目结构设计 有过 Java 开发经验的伙伴应该了解，SpringBoot 遵循着 MVC 的设计理念，这一套设计理念一直沿用至今，他的优秀难以言喻，Gin 框架完全可以参照这个模式来做，如下是我个人设计的一套架构： ├── /cmd │ └── main.go ├── /config │ └── config.go │ └── config.yaml ├── /docs ├── /internal │ ├── /api │ │ ├── v1 │ │ │ ├── /routes.go │ ├── /app │ │ ├── loader.go │ │ ├── db.go │ │ └── ... │ ├── /controller │ │ ├── user_controller.go │ │ └── ... │ ├── /middleware │ │ ├── error.go │ │ └── ... │ ├── /models │ │ ├── user_entity.go │ │ └── ... │ ├── /repositories │ │ ├── user_repository.go │ │ └── ... │ ├── /services │ │ ├── user_service.go │ │ └── ... │ └── /utils ├── /pkg ├── /scripts ├── /test ├── .env ├── go.mod ├── go.sum ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:3:0","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"三、目录职责 /cmd 存放应用的入口文件。 main.go：是整个应用的入口，在这里启动应用。 /config 存放应用的配置文件和配置加载逻辑。 config.go：包含配置加载和解析的逻辑。 config.yaml：应用的配置文件，通常包含数据库连接信息、服务器设置等。 /docs 存放应用的文档，如API文档、用户手册等。 /internal 存放应用的内部逻辑，这些代码不能被外部包所引入，可根据实际需求进而拆分目录。 api：包含应用中核心的业务路由等，即URL路径与控制器方法的映射。 app：包含应用的核心逻辑，如初始化、启动等。 controllers：包含控制器逻辑，处理请求并返回响应。 middleware：存放中间件代码，用于在请求处理流程中的特定阶段执行代码。 models：定义应用的数据模型，通常与数据库表结构对应。 repositories：实现数据访问逻辑，与数据库进行交互。 services：实现业务逻辑，调用repositories中的方法来处理业务需求。 utils：包含通用的工具函数，这些函数可以被多个包所共享。 /pkg 存放第三方库，如第三方中间件、工具库等。 /scripts 存放各种脚本，如项目部署脚本、测试脚本等。 /tests 存放测试代码，包括单元测试、集成测试等。 这里的目录结构可以根据需要自行组织，以支持不同类型的测试。 以上目录结构有助于清晰地分离应用的不同部分，使得代码更加模块化、易于理解和维护。同时，我也参照众多优秀开源项目的目录搭建思想，使其完美遵循了 Go 语言的最佳实践。 ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:4:0","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"四、实践 目录搭建好后，开始填充代码 下边简单实现集成数据库，配置路由，启动服务 ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:5:0","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"1、配置config 在 config.yaml 文件下配置端口和数据库连接，这里选择xorm： # 基础配置 app: port: 8080 database: driver: mysql source: root:123456@tcp(127.0.0.1:3306)/xxx_table?charset=utf8mb4\u0026parseTime=True\u0026loc=Local 在 config.go 下解析配置 package config import ( \"fmt\" \"github.com/spf13/viper\" ) type Config struct { App AppConfig `yaml:\"app\" mapstructure:\"app\"` Database DatabaseConfig `yaml:\"database\" mapstructure:\"database\"` } type AppConfig struct { Port int `mapstructure:\"port\"` } type DatabaseConfig struct { Driver string `yaml:\"driver\" mapstructure:\"driver\"` Source string `yaml:\"source\" mapstructure:\"source\"` } var Conf *Config // LoadConfig 加载配置文件 func LoadConfig() error { // 设置配置文件路径和名称 viper.AddConfigPath(\"./config\") viper.SetConfigName(\"config\") viper.SetConfigType(\"yaml\") // 读取配置文件 err = viper.ReadInConfig() if err != nil { return fmt.Errorf(\"读取配置文件失败: %v\", err) } // 将配置文件内容解析到 Conf 变量中 Conf = \u0026Config{} err = viper.Unmarshal(Conf) if err != nil { return fmt.Errorf(\"解析配置文件失败: %v\", err) } return nil } ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:5:1","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"2、配置init 数据库及其他的初始化统一放置到 app 目录下，在这里新建 loader.go 来初始化 mysql，但是为了之后方便管理，我们另单独创建 db.go 文件： 如需要加载其他如 redis，那就新建 redis.go 文件 package app import ( _ \"github.com/go-sql-driver/mysql\" \"github.com/go-xorm/xorm\" log \"github.com/sirupsen/logrus\" \"yourProject/config\" ) var Engine *xorm.Engine // InitializeMySQL 数据库初始化 func InitializeMySQL() error { var err error // 创建数据库引擎 Engine, err = xorm.NewEngine(config.Conf.Database.Driver, config.Conf.Database.Source) if err != nil { log.Error(\"数据库初始化失败: %v\", err) return err } // 测试数据库连接 if err = Engine.Ping(); err != nil { log.Error(\"数据库连接失败: %v\", err) return err } return nil } app.go 中调用 InitializeMySQL() package app import ( \"fmt\" ) // InitializeAll 初始化所有模块 func InitializeAll() error { err := InitializeMySQL() if err != nil { return fmt.Errorf(\"MySQL初始化错误: %v\", err) } return nil } ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:5:2","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"3、配置model 在 models 下新建 user_entity.go，注意：这个需要和数据库对应 package models type User struct { Id int64 `xorm:\"pk autoincr 'id'\"` UserID int64 `xorm:\"not null 'user_id'\"` Password string `xorm:\"varchar(50) not null 'password'\"` UserName string `xorm:\"varchar(30) 'user_name'\"` Email string `xorm:\"varchar(50) 'email'\"` PhoneNumber int64 `xorm:\"'phone_number'\"` Sex string `xorm:\"char(1) 'sex'\"` Remark string `xorm:\"varchar(500) 'remark'\"` } // TableName 方法用于返回表名 func (u User) TableName() string { return \"user\" } ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:5:3","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"4、配置controller 在 controllers 下新建 user_controllers.go package controllers import ( \"your_project/internal/services\" \"github.com/gin-gonic/gin\" \"net/http\" ) type UserController struct { UserService *services.UserService } func NewUserController(UserService *services.UserService) *UserController { return \u0026UserController{UserService: UserService} } func (uc *UserController) GetUsers(c *gin.Context) { users, err := uc.UserService.GetUsers() if err != nil { c.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to fetch users\"}) return } c.JSON(http.StatusOK, gin.H{\"users\": users}) } ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:5:4","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"5、配置service 在 sevices 下新建 user_service.go package services import ( \"your_project/internal/models\" \"your_project/internal/repositories\" \"github.com/go-xorm/xorm\" ) type UserService struct { userRepo *repositories.UserRepository } func NewUserService(engine *xorm.Engine) *UserService { return \u0026UserService{userRepo: repositories.NewUserRepository(engine)} } func (us *UserService) GetUsers() ([]*models.User, error) { return us.userRepo.GetUsers() } ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:5:5","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"6、配置repositorie 在 repositories 下新建 user_repo.go package repositories import ( \"your_project/internal/models\" \"github.com/go-xorm/xorm\" ) type UserRepository struct { engine *xorm.Engine } func NewUserRepository(engine *xorm.Engine) *UserRepository { return \u0026UserRepository{engine: engine} } // GetUsers 获取所有用户 func (r *UserRepository) GetUsers() ([]*models.User, error) { var users []*models.User err := r.engine.Table(models.User{}.TableName()).Find(\u0026users) return users, err } ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:5:6","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"7、配置api routes.go 中设置路由，这里设置路由组，为方便日后迭代 package v1 import ( \"github.com/gin-gonic/gin\" \"github.com/go-xorm/xorm\" \"your_project/internal/controllers\" \"your_project/internal/services\" ) func SetupRoutes(r *gin.Engine, engine *xorm.Engine) { // 定义用户路由组 user := r.Group(\"/user\") { // 创建 UserService 实例 UserService := services.NewUserService(engine) // 创建 UserController 实例 UserController := controllers.NewUserController(UserService) user.GET(\"/\", UserController.GetUsers) } } ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:5:7","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"8、配置main package main import ( \"fmt\" \"github.com/gin-gonic/gin\" log \"github.com/sirupsen/logrus\" \"your_project/config\" \"your_project/internal/api/v1\" \"your_project/internal/app\" ) func main() { // 加载配置文件 err := config.LoadConfig() if err != nil { log.Error(\"配置文件加载错误: %v\", err) return } // 初始化所有模块 err = InitializeAll() if err != nil { log.Error(\"模块初始化错误: %v\", err) return } r := gin.Default() v1.SetupRoutes(r, Engine) err = r.Run(fmt.Sprintf(\":%d\", config.Conf.App.Port)) if err != nil { log.Error(\"服务启动错误: %v\", err) return } } 截至这里，基本的一个查询请求就已经构建好了 ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:5:8","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":["golang"],"content":"7、启动项目 cmd 目录下直接运行 main 函数，正常会输出如下信息： Listening and serving HTTP on :8080 接着访问 http://localhost:8080/user 正常查询结果回显 json 如下： { \"users\": [ { \"Id\": 1, \"UserID\": \"000001\", \"Password\": \"123456\", ... } ] } ","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:5:9","tags":["golang","gin"],"title":"Go 项目实战：搭建高效的Gin Web目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":null,"content":"欢迎莅临我的博客 “分享你的想法，这里永远有倾听的耳朵” —— 留言板寄语 ","date":"2025-01-14","objectID":"/message/:1:0","tags":null,"title":"留言板","uri":"/message/"},{"categories":null,"content":"留言板功能说明 基础留言：直接在下方评论区书写 格式支持： 支持加粗、斜体、~~删除线~~ 支持代码片段和代码块： print(\"Hello, 留言板!\") 支持表情符号 😊 ✅ 🌟 ","date":"2025-01-14","objectID":"/message/:1:1","tags":null,"title":"留言板","uri":"/message/"},{"categories":["golang"],"content":"首先我们先明确下 json 包下 Unmarshal() 函数是什么： 它是 Go 语言标准库 encoding/json 中的一个函数，用于将 JSON 数据解析为 Go 语言中的数据结构。它的作用是将一个 JSON 格式的字节切片（[]byte）转换为对应的 Go 语言数据类型，如结构体、切片、映射等。 其次了解了它的作用后，再来看下这个坑点： 假设有一个 json 串如下： { \"id\": 1, \"name\": \"张三\", \"age\": 20 } 现在要将它解析成一个 map，拿到 json 原始的数据，方便后续处理： func main() { str := \"{\\\"id\\\":1,\\\"name\\\":\\\"张三\\\",\\\"age\\\":20}\" jsonMap := make(map[string]interface{}) json.Unmarshal([]byte(str), \u0026amp;jsonMap) // 遍历map for key, value := range jsonMap { fmt.Printf(\"key: %s, value: %v\\n\", key, value) } } // 输出： // key: id, value: 1 // key: name, value: 张三 // key: age, value: 20 这样看着确实没什么问题，每个 key、value 值都是按照预期输出； 现在我把 json 调整一下，假设 id 是一个毫秒级时间戳 1736325205000（13 位）： func main() { str := \"{\\\"id\\\":1736325205000,\\\"name\\\":\\\"张三\\\",\\\"age\\\":20}\" jsonMap := make(map[string]interface{}) json.Unmarshal([]byte(str), \u0026amp;jsonMap) // 遍历map for key, value := range jsonMap { fmt.Printf(\"key: %s, value: %v\\n\", key, value) } } // 输出 // key: id, value: 1.736325205e+12 // key: name, value: 张三 // key: age, value: 20 此时坑来了， id 的值变成了一个科学计数法的字符串，显然这不符合我的预期； 那么为什么会变成这样呢？ 首先观察到我使用了 %v 进行处理，然而 json 中原本的数据是一个 int，我应该用处理 int 的占位符 %d ： func main() { str := \"{\\\"id\\\":1736325205000,\\\"name\\\":\\\"张三\\\",\\\"age\\\":20}\" jsonMap := make(map[string]interface{) json.Unmarshal([]byte(str), \u0026amp;jsonMap) fmt.Printf(\"%d\",jsonMap[\"id\"]) } // 输出 // %!d(float64=1.736325205e+12) 到这里本以为是 ok 的，结果输出了这么个玩意，仔细读一下发现 float64 ，输出这个的原因是我要把一个 float64 的元素强行用 int 类型的占位符进行处理； 所以现在进一步清晰了，json.Unmarshal 函数会把 id 转为 float64； 那么问题又来了，为什么它会把 id 转为 float64 类型呢？id == 1 的时候为什么能正常输出呢？ 进源码，看看函数内部做了什么： func Unmarshal(data []byte, v any) error { // Check for well-formedness. // Avoids filling out half a data structure // before discovering a JSON syntax error. var d decodeState err := checkValid(data, \u0026amp;d.scan) if err != nil { return err } d.init(data) return d.unmarshal(v) } // 可以看到 checkValid() 方法引用了 decodeState 结构体 // 进结构体里看下： // decodeState represents the state while decoding a JSON value. type decodeState struct { data []byte off int // next read offset in data opcode int // last read result scan scanner errorContext *errorContext savedError error useNumber bool disallowUnknownFields bool } // 初步观察有个 bool 类型的 useNumber 属性 // 接着看下这个结构体具体的实现方法： // convertNumber converts the number literal s to a float64 or a Number // depending on the setting of d.useNumber. func (d *decodeState) convertNumber(s string) (any, error) { if d.useNumber { return Number(s), nil } f, err := strconv.ParseFloat(s, 64) if err != nil { return nil, \u0026amp;UnmarshalTypeError{Value: \"number \" + s, Type: reflect.TypeOf(0.0), Offset: int64(d.off)} } return f, nil } // 到这里大概能清楚，是这个方法把我的 id 转成了 float64，但是再转之前还有一层 if 会把原始值输出； // 接下来就回去上一级，看看 d.scan 到底做了什么： // 努力中... // ——————看不懂 经过多方查找： 理论上 json 会把超过 int64 长度的数字转成 float64，但是这个说法经实践不成立，毫秒级时间戳 13 位，远没有超过 int64 的最大长度； 多次翻阅资料后，有一个说法比较靠谱： 当处理非常大的整数（如毫秒级的时间戳）时，如果直接使用 Go 语言中的整数类型（如 int 或 int64），可能会因为超出这些类型的表示范围而导致溢出。虽然 int64 类型在大多数情况下可以容纳毫秒级的时间戳，但为了确保能够处理所有可能的 JSON 数字，encoding/json 包选择了 float64 类型作为默认解析结果。 到这里其实我们最初的目的也轻松处理： func main() { str := \"{\\\"id\\\":1736325205000,\\\"name\\\":\\\"张三\\\",\\\"age\\\":20}\" jsonMap := make(map[string]interface{}) json.Unmarshal([]byte(str), \u0026amp;jsonMap) // 断言类型为 float64 fmt.Println(jsonMap[\"id\"]) if f, ok := jsonMap[\"id\"].(float64); ok { fmt.Println(int(f)) } } // 输出 // 1736325205000 ","date":"2025-01-12","objectID":"/posts/json_unmarshall_parsing_numeric_types/:0:0","tags":["golang"],"title":"Json.Unmarshal 解析数字类型（踩坑）","uri":"/posts/json_unmarshall_parsing_numeric_types/"},{"categories":["golang"],"content":"高效地处理多个数据源并将其整合为有意义的结果是开发中一项重要的任务。Go 语言，以其强大的并发特性，为我们提供了优雅而高效的解决方案。那么我们探讨一下如何利用 Go 语言的协程，同时调用多个接口获取数据，并将这些数据无缝地合并为一个完整的数据集。 先假定一个场景：现有一需求，需要请求n个接口（暂定为3个）获取接口数据，然后对数据进行二次处理并返回。 按照过往的经验，我们会依次请求接口拿到数据暂存，最后对数据进行包装处理，这种自上而下的处理方式其实并无不妥，现在想要提高下效率，利用牺牲cpu资源来换取查询性能。 先模拟创建几个接口，分别返回(k1，v1)、(k2，v2)、(k3，v4)： // 模拟接口A func getDataFromA() map[string]interface{} { return map[string]interface{}{ \"key1\": \"value1\", } } // 模拟接口B func getDataFromB() map[string]interface{} { return map[string]interface{}{ \"key2\": \"value2\", } } // 模拟接口C func getDataFromC() map[string]interface{} { return map[string]interface{}{ \"key3\": \"value3\", } } 开启协程分别请求上述接口： 首先得思考一个问题，协程执行不保证顺序，请求到的数据应该怎么保存？怎么判断全部协程都执行完毕？怎么拿到全部的数据？ 上述接口定义中返回的数据均是map，那么我完全可以用map来保存数据，所以我定义方法就可以这么定义： func getAllData() map[string]interface{} { return nil // 暂时先不做处理 } 为了防止主协程先于其他执行结束，需要引入 sync.WaitGroup 包控制；所有协程返回的数据，可以用通道来暂存，make 一个容量为 3 的 Channel： func getAllData() map[string]interface{} { var wg sync.WaitGroup resultChan := make(chan map[string]interface{}, 3) return nil // 暂时先不做处理 } 接下来就可以开启协程去调用: func getAllData() map[string]interface{} { var wg sync.WaitGroup resultChan := make(chan map[string]interface{}, 3) wg.Add(3) go func() { defer wg.Done() resultChan \u003c- getDataFromA() }() go func() { defer wg.Done() resultChan \u003c- getDataFromB() }() go func() { defer wg.Done() resultChan \u003c- getDataFromC() }() wg.Wait() close(resultChan) return nil // 暂时先不做处理 } 最后可以对数据做个简单处理，封装成一个大map返回，实际业务当然按需处理： newMap := make(map[string]interface{}) for res := range resultChan { for k, v := range res { newMap [k] = v } } return newMap 执行验证返回结果： [Running] go run \"main.go\" map[key1:value1 key2:value2 key3:value3] ","date":"2025-01-12","objectID":"/posts/collaborative_processing_of_multiple_interfaces/:0:0","tags":["golang","并发","协程"],"title":"Go 语言并发实战：利用协程处理多个接口的 Map 数据融合","uri":"/posts/collaborative_processing_of_multiple_interfaces/"},{"categories":["golang"],"content":"在如今的编程领域，一个程序能够同时处理多个任务的能力非常重要，而 Golang 在并发编程方面表现十分出色，具有很多独特的优势。 ","date":"2025-01-12","objectID":"/posts/the_concurrency_advantage_of_go/:0:0","tags":["golang","并发"],"title":"Go 语言的并发优势","uri":"/posts/the_concurrency_advantage_of_go/"},{"categories":["golang"],"content":"一、轻量级的协程（Goroutine） 在传统的像 Java 这样的编程语言中，创建线程来实现并发往往需要较大的资源开销和复杂的管理。但在 Golang 里，有了 Goroutine 就截然不同。 Goroutine 的创建几乎不费力气，我们可以毫无压力地同时启动成千上万的 Goroutine 来完成不同的任务，而且不用担心资源被大量消耗。 举个例子： package main import ( \"fmt\" \"time\" ) func task() { fmt.Println(\"Hello Goroutine!\") } func main() { go task() time.Sleep(1 * time.Second) } 在这段代码里，我们用 go task() 轻松地启动了一个 Goroutine 去执行 task 函数。 当然这样可能更直观： package main import ( \"fmt\" \"time\" ) func main() { go func() { fmt.Println(\"Hello Goroutine!\") }() time.Sleep(1 * time.Second) } ","date":"2025-01-12","objectID":"/posts/the_concurrency_advantage_of_go/:1:0","tags":["golang","并发"],"title":"Go 语言的并发优势","uri":"/posts/the_concurrency_advantage_of_go/"},{"categories":["golang"],"content":"二、高效的通道（Channel） 在并发编程中，不同的任务之间需要数据通信。Golang 里的通道（Channel）就像是一个专门的管道，使得数据通信安全又高效。 package main import \"fmt\" func main() { ch := make(chan int) // 无缓冲的通道 go func() { ch \u003c- 1 }() num := \u003c-ch fmt.Println(num) } 通过这个通道 ch，我们成功地在两个不同的 Goroutine 之间传递了数据。 ","date":"2025-01-12","objectID":"/posts/the_concurrency_advantage_of_go/:2:0","tags":["golang","并发"],"title":"Go 语言的并发优势","uri":"/posts/the_concurrency_advantage_of_go/"},{"categories":["golang"],"content":"三、优秀的内存管理和并发调度 在编程语言中，内存管理和并发调度是影响程序性能和稳定性的关键因素。Golang 在这两个方面展现出了卓越的特性。 Golang 拥有一套自动且高效的内存回收机制。这意味着开发者无需像在 Java 等语言中那样，时刻关注内存的分配与释放，避免了因手动管理内存而可能导致的内存泄漏和野指针等问题。这种自动内存管理机制不仅减轻了开发者的负担，还提高了程序的可靠性和可维护性。 同时，Golang 的并发调度机制极具智能性。它能够根据系统的负载和各个 Goroutine 的状态，合理地分配 CPU 资源，确保每个 Goroutine 都能获得公平的执行机会。与 Java 等语言的线程调度相比，Golang 的调度更加轻量和灵活，能够在高并发场景下实现更高效的资源利用，从而显著提升程序的整体性能和响应速度。 ","date":"2025-01-12","objectID":"/posts/the_concurrency_advantage_of_go/:3:0","tags":["golang","并发"],"title":"Go 语言的并发优势","uri":"/posts/the_concurrency_advantage_of_go/"},{"categories":["golang"],"content":"四、简洁而强大的并发编程模型 Golang 的并发编程模型以其简洁性和强大的功能而备受赞誉。 与 Java 等语言中相对复杂的并发控制机制（如锁、条件变量等）不同，Golang 提供了一种更为直观和易于理解的方式来处理并发。Goroutine 和 Channel 的组合使用，使得并发任务的创建、通信和同步变得清晰明了。开发者可以轻松地创建多个并发执行的任务，并通过 Channel 安全、高效地进行数据交换和协调。 此外，Golang 的并发错误处理机制也更加简洁和有效。它能够帮助开发者更快速地定位和解决并发环境中可能出现的问题，减少了因并发导致的错误排查难度和时间成本。这种简洁而强大的并发编程模型，极大地提高了开发者的生产效率，使他们能够更加专注于业务逻辑的实现，而不必在复杂的并发控制细节上耗费过多精力。 ","date":"2025-01-12","objectID":"/posts/the_concurrency_advantage_of_go/:4:0","tags":["golang","并发"],"title":"Go 语言的并发优势","uri":"/posts/the_concurrency_advantage_of_go/"},{"categories":["golang"],"content":"下载Golang 官网链接：https://golang.google.cn/dl/ ","date":"2025-01-12","objectID":"/posts/golang_development_environment/:1:0","tags":["golang"],"title":"Golang 开发环境搭建","uri":"/posts/golang_development_environment/"},{"categories":["golang"],"content":"配置环境 安装好之后须添加如下环境变量： 变更名 变量值 说明 GOPATH E:\\gowork Go语言的工作目录，存放自己编写的 .go 文件、项目、包、编译的二进制文件等 GOROOT D:\\go Go的安装路径 在 Path 路径下，新增 %GOROOT%\\bin ps: GOPATH 的值，需要根据实际情况按需配置，默认路径为C盘用户目录下 开启go mod 及配置国内代理： go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct ","date":"2025-01-12","objectID":"/posts/golang_development_environment/:2:0","tags":["golang"],"title":"Golang 开发环境搭建","uri":"/posts/golang_development_environment/"},{"categories":["golang"],"content":"配置vscode 安装 Go、vscode-go-syntax 两插件 届时，vscode 会弹出需要安装其他 go 扩展的提示，只需要 Install All 即可 如条件允许更推荐使用 GoLand 进行开发 ","date":"2025-01-12","objectID":"/posts/golang_development_environment/:3:0","tags":["golang"],"title":"Golang 开发环境搭建","uri":"/posts/golang_development_environment/"},{"categories":null,"content":"关于我 “生命不息，折腾不止！” —— 自我期许 一名后端工程师，热衷于钻研感兴趣之事，追求那点滴成就感，在代码世界中持续探索边界。 ","date":"2025-01-12","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"专业背景 教育经历：计算机科学与技术专业。 技术栈：Go（主力） / Java（熟练） / Python（辅助）。 从业经历：3年+经验，先后涉足资管业务、消费金融、CRM等领域，现工作于某一线互联网企业。 ","date":"2025-01-12","objectID":"/about/:1:1","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于博客 不定期记录技术思考与实践，分享踩坑经验与解决方案，与开发者同行共进。 欢迎通过我的 GitHub 或 RSS 订阅本博客。 ","date":"2025-01-12","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"博客历程 大学开启编程之旅，白天上课，夜晚在 bilibili 汲取知识，受 遇见狂胜说 启发开启博客创作。 在 博客园 注册自己的第一个博客，发表了几篇随笔，收获不少访问量，心中大喜。 2019 - 2020由于无法接受博客园太过复古的 UI ，期间不断的找寻美化方案，但始终不尽如我意，而后转战 CSDN 。 2020 - 2021长期混迹在 CSDN ，期间发表些许文章，收获众多点赞收藏加转载，曾也上过周榜Top5。 2021 - 2024因 CSDN 商业化太过严重，思索再三决定注销账号，用 Github Page 打造自己的一片净土。 2025 - 01未来继续折腾，持续在个人博客分享技术，探索更多内容形式。🚀 ","date":"2025-01-12","objectID":"/about/:2:1","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"联系我 技术交流： 留言板 Email： chihpengliu.cn@outlook.com ","date":"2025-01-12","objectID":"/about/:3:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"声明 ","date":"2025-01-12","objectID":"/about/:4:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"内容使用 本站遵循 CC BY-NC-SA 4.0 协议： 署名要求：分享或演绎时，请明确注明原始内容的作者及来源，以示尊重版权。 非商用性：所有使用、分享或演绎均限于非商业目的，不得用于盈利活动。 相同授权：确保其他用户能在相同条件下访问和使用您分享或演绎的内容。 ","date":"2025-01-12","objectID":"/about/:4:1","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"免责声明 用户言论：评论将永久存档，请勿包含个人隐私信息，发言需符合所在地区法律法规。 第三方内容：引用内容仅作信息传递之用，不对其准确性作担保，使用前请自行核验。 责任范围：因使用本站内容造成的直接/间接损失，本站不承担任何法律责任。 ","date":"2025-01-12","objectID":"/about/:4:2","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"正在建设中… ","date":"2025-01-12","objectID":"/link/:0:0","tags":null,"title":"友链","uri":"/link/"}]