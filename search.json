[{"categories":["Golang","算法"],"content":"排序是算法世界中最基础也最常用的操作之一，无论是面试准备、日常开发还是学习巩固，清晰可靠的排序算法实现都是程序员工具箱里的必备品。 本文不追求冗长的理论推导，而是聚焦于提供清晰、可运行的核心代码实现。 冒泡排序 冒泡排序的基本思路是通过重复遍历要排序的列表，比较相邻的两个元素，如果它们的顺序错误（即，前一个大于后一个），就交换它们的位置。遍历列表的工作会重复进行，直到没有需要交换的元素为止。 其时间复杂度是 \\(O(n^2)\\)，n 为数组的长度。 图解： func bubbleSort(arr []int) { for i := 0; i \u003c len(arr)-1; i++ { for j := 0; j \u003c len(arr)-i-1; j++ { // 比较相邻元素，如果前一个元素大于后一个元素，则交换它们 if arr[j] \u003e arr[j+1] { arr[j], arr[j+1] = arr[j+1], arr[j] } } } } 选择排序 选择排序的基本思路是每轮从未排序部分选择最小元素放到已排序部分的末尾，直到所有元素排序完成。 其时间复杂度是 \\(O(n^2)\\)，n 为数组的长度。 图解： func selectionSort(arr []int) { for i := 0; i \u003c len(arr)-1; i++ { minIndex := i for j := i + 1; j \u003c len(arr); j++ { // 找到最小的元素索引 if arr[j] \u003c arr[minIndex] { // 更新最小元素索引 minIndex = j } } // 交换元素 arr[i], arr[minIndex] = arr[minIndex], arr[i] } } 插入排序 插入排序的基本思路是将数组分为已排序部分和未排序部分，从未排序部分中取出一个元素，将其插入已排序部分的正确位置，直到所有元素排序完成。 其时间复杂度是 \\(O(n^2)\\)，n为数组的长度。 图解： func insertionSort(arr []int) { for i := 1; i \u003c len(arr); i++ { key := arr[i] j := i - 1 // 将大于 key 的元素向后移动 for j \u003e= 0 \u0026\u0026 arr[j] \u003e key { arr[j+1] = arr[j] j-- } // 将 key 插入已排序部分的正确位置 arr[j+1] = key } } ","date":"2025-08-16","objectID":"/posts/algorithm_implementation_example_sort/:0:0","tags":["算法"],"title":"算法实现示例集：排序","uri":"/posts/algorithm_implementation_example_sort/"},{"categories":["Golang"],"content":"在构建安全可靠的 Go Web 服务时，JWT(JSON Web Token)认证是常用的解决方案。本文将介绍如何在 Gin 框架中实现完整的 JWT 认证方案，同时包含灵活的 Redis 集成选项。 一、为什么需要 JWT 中间件 JWT 作为现代 Web 开发的认证标准，相比传统 cookie + session 方式有几个明显优势： 无状态性：服务器不需要存储会话信息 跨域支持：天然支持跨域认证 安全传输：基于签名机制防止篡改 信息自包含：Token 本身携带用户信息 在 Gin 框架中通过中间件实现 JWT 认证，可以统一处理认证逻辑，避免每个路由重复编写验证代码。 二、核心依赖包 开始前需要安装如下包： go get github.com/gin-gonic/gin go get github.com/golang-jwt/jwt/v5 go get github.com/redis/go-redis/v9 # 可选，按需安装 三、实现方案设计 在实现 JWT 认证中间件时，我们的设计方案需要兼顾灵活性和安全性。整个流程可以分为几个关键步骤： 初始化配置：从配置文件或环境变量中加载 JWT 的配置（如密钥、签发者、签名算法、过期时间等）。我们使用单例模式确保配置只加载一次，并通过互斥锁保证并发安全。 中间件流程： 排除特定路由：对于不需要认证的路由（如登录、公开资源），直接跳过 JWT 验证。 解析 Authorization 头：从请求头中提取 Bearer Token，并验证其格式是否正确。 验证 Token：根据是否启用 Redis，采用不同的验证方式： 如果启用了 Redis，首先尝试从 Redis 中获取该 Token 对应的声明（claims）。如果存在且有效，则直接使用；如果不存在或无效，则回退到JWT库的验证方式。 如果没有启用 Redis，则直接使用 JWT 库验证 Token 的签名和有效期。 处理验证结果：如果验证通过，将 claims 存储到 Gin 的上下文中，供后续处理函数使用；如果验证失败，则根据具体的错误类型返回相应的错误信息。 Token 生成：在用户登录成功后，生成 JWT Token。Token 中包含用户的身份信息（如用户ID和用户名）以及 JWT 的标准声明（如过期时间、签发者等）。如果启用了 Redis，还需要将 Token 和对应的声明存储到 Redis 中，并设置与Token相同的过期时间。 错误处理：针对 JWT 验证过程中可能出现的错误（如 Token 过期、格式错误、签名无效等），提供清晰的错误信息，方便前端处理。 配置管理：提供重置配置的功能，以便在需要时（如密钥轮换）重新加载配置。 为了更直观地理解上述流程，下面用一个流程图表示： graph TD A[客户端请求] --\u003e B{JWT中间件} B --\u003e C{是否排除路径?} C --\u003e|是| D[跳过验证] C --\u003e|否| E[解析Token] E --\u003e F{Redis启用?} F --\u003e|是| G[从Redis获取认证信息] F --\u003e|否| H[本地验证JWT签名] G \u0026 H --\u003e I[校验通过?] I --\u003e|是| J[存储claims到上下文] I --\u003e|否| K[返回错误响应] graph TD A[客户端请求] --\u003e B{JWT中间件} B --\u003e C{是否排除路径?} C --\u003e|是| D[跳过验证] C --\u003e|否| E[解析Token] E --\u003e F{Redis启用?} F --\u003e|是| G[从Redis获取认证信息] F --\u003e|否| H[本地验证JWT签名] G \u0026 H --\u003e I[校验通过?] I --\u003e|是| J[存储claims到上下文] I --\u003e|否| K[返回错误响应] graph TD A[客户端请求] --\u003e B{JWT中间件} B --\u003e C{是否排除路径?} C --\u003e|是| D[跳过验证] C --\u003e|否| E[解析Token] E --\u003e F{Redis启用?} F --\u003e|是| G[从Redis获取认证信息] F --\u003e|否| H[本地验证JWT签名] G \u0026 H --\u003e I[校验通过?] I --\u003e|是| J[存储claims到上下文] I --\u003e|否| K[返回错误响应] graph TD A[客户端请求] --\u003e B{JWT中间件} B --\u003e C{是否排除路径?} C --\u003e|是| D[跳过验证] C --\u003e|否| E[解析Token] E --\u003e F{Redis启用?} F --\u003e|是| G[从Redis获取认证信息] F --\u003e|否| H[本地验证JWT签名] G \u0026 H --\u003e I[校验通过?] I --\u003e|是| J[存储claims到上下文] I --\u003e|否| K[返回错误响应] 四、实战 1.配置结构定义 // JWT核心配置 type JWTConfig struct { Secret []byte // 加密密钥 - 建议使用32字节安全随机数 Issuer string // 签发者 - 通常为服务名称 SigningMethod jwt.SigningMethod // 签名算法 - 支持HS256/HS384/HS512 ExpirationTime time.Duration // 有效时长 - 如24h, 15m等 } // 自定义Claims结构 type CustomClaims struct { UserID int `json:\"userID\"` // 用户ID UserName string `json:\"userName\"` // 用户名 jwt.RegisteredClaims // JWT标准字段 } // 全局配置实例（线程安全） var ( jwtConfig *JWTConfig mutex sync.Mutex ) 2.JWT 中间件实现 func JwtMiddleware() gin.HandlerFunc { // 定义排除路径（支持通配符） excludedPaths := map[string]bool{ \"/api/v1/login\": true, \"/public/*\": true, \"/healthcheck\": true, } return func(c *gin.Context) { // 检查当前路径是否在排除列表中 for path := range excludedPaths { if match, _ := filepath.Match(path, c.Request.URL.Path); match { c.Next() // 放行请求 return } } // 获取Authorization头 authHeader := c.GetHeader(\"Authorization\") if authHeader == \"\" { c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{ \"code\": 40101, \"message\": \"Authorization header is required\", }) return } // 解析Bearer Token tokenString, err := parseBearerToken(authHeader) if err != nil { c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{ \"code\": 40102, \"message\": \"Invalid token format\", }) return } // 验证Token claims, err := validateJWT(tokenString) if err != nil { handleJWTError(c, err) // 处理各类验证错误 return } // 存储claims到上下文（后续路由可通过c.Get(\"jwt_claims\")获取） c.Set(\"jwt_claims\", claims) c.Next() } } 3.Token 生成 // 登录成功时调用 func GenerateToken(userID int, userName string) (string, error) { conf := config.LoadConfig() // 加载应用配置 jwtConf, err := loadJwtConfig(conf) if err != nil { return \"\", fmt.Errorf(\"failed to load JWT config: %w\", err) } // 创建Claims对象 claims := CustomClaims{ UserID: userID, UserName: userName, RegisteredClaims: jwt.RegisteredClaims{ ExpiresAt: jwt.NewNumericDate(time.Now().Add(jwtConf.ExpirationTime)), IssuedAt: jwt.NewNumericDate(time.Now()), Issuer: jwtConf.Issuer, // 可添加更多声明如：Subject, Audience等 }, } // 创建并签名Token token := jwt.NewWithClaims(jwtConf","date":"2025-07-25","objectID":"/posts/go_practice_implementing_jwt_auth_middleware/:0:0","tags":["Golang","Gin","JWT"],"title":"Go 项目实战：实现 JWT 认证中间件","uri":"/posts/go_practice_implementing_jwt_auth_middleware/"},{"categories":null,"content":"内容使用 本站遵循 CC BY-NC-SA 4.0 协议： 署名要求：分享或演绎时，请明确注明原始内容的作者及来源，以示尊重版权。 非商用性：所有使用、分享或演绎均限于非商业目的，不得用于盈利活动。 相同授权：确保其他用户能在相同条件下访问和使用您分享或演绎的内容。 免责声明 用户言论：评论将永久存档，请勿包含个人隐私信息，发言需符合所在地区法律法规。 第三方内容：引用内容仅作信息传递之用，不对其准确性作担保，使用前请自行核验。 责任范围：因使用本站内容造成的直接/间接损失，本站不承担任何法律责任。 ","date":"2025-07-20","objectID":"/statement/:0:0","tags":null,"title":"声明","uri":"/statement/"},{"categories":["Golang"],"content":"前言：如下题目于面试结束两周后，整理了当初未能回答上来的问题，在此分享总结，以供参考。 一、常见的 GC 算法有哪些，Go 是怎么做的 当时对这个问题的了解程度更多的停留在各类技术文章或网传八股文面试题中，没有对 GC 有更广更深入的了解，栽到了一些细节上。 1.常见的 GC 算法 引用计数 为每个对象维护一个计数器，该对象被使用就 +1，使用结束后 -1，当该对象计数器归 0 时，即被认定为可回收对象，但是一般不立即回收，出于效率考虑，系统一般会定期的等待一批可回收对象一块回收。同时存在个弊端，对于循环引用的对象，计数器的值始终不为 0，无法被回收。 标记清除 引入了 “可达对象” 的概念（双方存在直接或间接的引用关系），从根对象开始扫描遍历所有可达对象并标记为 “存活”，然后扫描整个堆内存，回收未被标记的对象。解决了上述循环引用的问题，但是会因为 STW （Stop The World，程序暂停执行）导致性能开销较大，多次 GC 后，内存会不连续碎片化。 标记整理 标记阶段同标记清除算法一样，在整理阶段不直接清除，而是将对象向内存一端移动，然后清除端边界外的所有空间。优点解决了内存不连续碎片化的问题，但是因为多了对对象在内存的移动整理过程，使得整体的性能开销更大。 标记复制 标记阶段依然同标记清除算法一样，区别于标记整理，而是将内存分为大小相等的两块，每次只使用一块，GC 是将所有的可达对象复制到另一块内存空间，然后清除当前块。优点同样可以解决内存不连续碎片化的问题，缺点只能使用整个内存空间的一半，同样因为存在复制过程，所以整体开销也不小。 2.Go 采用的 GC 算法 标记清除（三色标记法） 定义三个颜色： 白色：未被标记的对象 灰色：已被标记，但还未处理完其所有可达对象 黑色：已被标记且处理完所有可达对象 GC 过程： 初始化：把所有的对象均标记为白色 标记：从根对象开始，把所有可达对象标记为灰色，当前对象标记为黑色，循环这个过程，直到所有可达对象都被标记，换言之所有对象不是黑色就是白色 清除：清除所有白色对象 优点： 在 1.5 版本的时候引入了三色标记算法，减少了 STW 时间 在 1.8 版本的时候引入混合写入屏障，进一步压缩 STW 时间 ps ：在引用赋值时，将新对象标记为灰色，在引用被删除前，将被删除的对象标记为灰色。 3.思考 标记的时候，所谓的根对象是什么？或者说根对象在哪里？ 结合上述的标记清除的过程，当前对象存在可达对象的时候或者说当前对象被其他对象所引用，自身就会标记为黑色，那么可以得出如果自身没有引用其他对象的时候，那么自身就是所谓的根对象。 结合 go 语言特性，思考哪些对象是存在上述特征，换个角度出发，当程序开始运行的时候，首次被加载到内存的对象就符合该特征，那么例如全局常量，包级变量，每个 goroutine 的局部变量常量等即为根对象。 二、互斥锁底层数据结构是什么样的 互斥锁仅停留在使用的层面，如多线程并发中保护资源等操作上，对于底层是如何实现的，属于是被问到知识盲区了。 Golang 的互斥锁主要由内部 sync 包下的 Mutex 对象实现。 跳进该对象内部（源码），可看到该对象定义了两个变量：state \u0026 sema，这也是互斥锁的核心数据结构： type Mutex struct { state int32 // 状态 sema uint32 // 信号量 } 往下翻可看到定义的几个常量，这几个常量是互斥锁底层状态管理的核心： const ( mutexLocked = 1 // 锁被持有 mutexWoken // 锁被释放 mutexStarving // 锁处于饥饿模式 mutexWaiterShift = iota // 等待者数量的偏移量，值为 3 ) 接着进一步分析该对象下的具体方法（加锁 \u0026 解锁）： func (m *Mutex) Lock() { // Fast path: grab unlocked mutex. if atomic.CompareAndSwapInt32(\u0026m.state, 0, mutexLocked) { if race.Enabled { race.Acquire(unsafe.Pointer(m)) } return } // Slow path (outlined so that the fast path can be inlined) m.lockSlow() } func (m *Mutex) lockSlow() { // 具体逻辑请移步源码 } func (m *Mutex) Unlock() { if race.Enabled { _ = m.state race.Release(unsafe.Pointer(m)) } // Fast path: drop lock bit. new := atomic.AddInt32(\u0026m.state, -mutexLocked) if new != 0 { // Outlined slow path to allow inlining the fast path. // To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock. m.unlockSlow(new) } } func (m *Mutex) unlockSlow(new int32) { // 具体逻辑请移步源码 } 可以看出整个加锁解锁的过程是原子性的，并且有两种途径加解锁（快速途径和慢速途径）粗略的分析了具体实现逻辑，大致总结如下（不保证准确性，仅供参考）： 后续不定期补充 加锁： 快速途径：如锁未被持有（state 低 3 位为 0）直接获取锁 慢速途径： 循环尝试获取锁 正常模式下，新请求可抢占锁，等待者可能被插队 饥饿模式下，锁直接交给队首等待者，新请求直接入队 若获取失败，通过 sema 阻塞当前 goroutine 解锁： 快速途径：直接解锁 慢速途径： 正常模式下：若存在等待者，唤醒一个 goroutine 饥饿模式下：直接将锁交给队首等待者 总结： Golang 的互斥锁的底层由两个变量 state 锁状态和 sema 信号量构成，并结合原子操作实现对线程加解锁的控制。 三、事务的四个特性分别通过什么手段实现的 本以为会问 ACID 的特性，这个倒是都了解，出乎意料的是底层是如何实现的，一下子有些猝不及防，脑子里闪过：约束？redo log？undo log？思索片刻还是放弃了。 1.原子性 定义：事务执行要么都成功要么都失败，不可分割 实现原理：利用 Undo Log（回滚日志），记录每一次执行对应的相反操作，例如：执行 INSERT 操作，那么日志中则记录对应的 DELETE 操作。一旦事务中某一条 SQL 执行失败，那么直接使用日志中记录的操作回滚到事务执行前的状态。 2.一致性 定义：事务执行前后，数据库中数据的一致性状态需保持一致 实现原理：执行事务时，InnoDB 会检查数据完整性约束（主键、唯一索引、外键）。若违反约束，事务会自动回滚，同时也包括业务规则上的约束，比如经典的银行转账问题，通过数据库触发器或应用层逻辑，确保业务规则被遵守。 3.隔离性 定义：多个事务并发执行时，相互隔离，互不干扰 实现原理：InnoDB 默认的隔离级别是可重复读，通过 MVCC 多版本并发控制机制，每个事务读取自己开始时的数据库快照，避免脏读、幻读、不可重复读问题。对于读已提交隔离级别来说，采用了行级锁来保证；对于串行来讲，直接使用表锁，强制让事务串行执行。 4.持久性 定义：事务一旦执行成功，其结果将持久化到磁盘中 实现原理：利用 Redo Log（重做日志），记录事务对数据页的物理修改（与 Undo Log 相反），按顺序写入磁盘，即使系统崩溃，过后可通过日志恢复未持久化的数据页。 四、如下代码分别输出什么 func main() { var a = []int{1, 2, 3} fmt.Println(len(a), cap(a)) a = append(a, 4, 5, 6, 7) fmt.Println(len(a), cap(a)) } 先前面试中印象里没有被问到这个问题，不过这个题蛮有意思，考察关于切片扩容的问题。 结论： \u003e 3 3 \u003e 7 8 原因： 先说长度：这个无可厚非，append 前 3 个元素，append 后追加了 4 个元素，所以长度第一次输出 3，第二次输出 7。 再来聊聊容量：虽然在 go 1.18 版本之前和之后对于基准容量的把控从 1024 更新到了 256，但在上述示例中可以忽略；首先初始的容量为 3，所以结果输出 3，随后进行了 append 操作，新增了 4 个元素进去，切片首先会进行 2 倍扩容：3 * 2 = 6，但是 6 的容量不足以容纳 7 个元素，理论上会采用最大的容量作为新容量也就是 7 ，但是 go 底层还有个逻辑，即为了内存对齐会选择不小于当前最大容量的最小 2 的幂次，也就是 8，所以第二次会输出 8。 五、爬楼梯问题 力扣第 70 题： 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 示例 1： 输入：n = 2 输出：2 解释：有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2： 输入：n = 3 输出：3 解释：有三种方法可以爬到楼顶。 1. 1 阶 + 1 ","date":"2025-06-07","objectID":"/posts/golang_development_job_interview/:0:0","tags":["面试"],"title":"记一次 Golang 开发岗面试","uri":"/posts/golang_development_job_interview/"},{"categories":["MySQL"],"content":"下载地址 官网链接：https://downloads.mysql.com/archives/community/ 配置文件 根目录下 my.ini 文件 [mysqld] # 设置MySQL服务的端口号，默认为3306 port=3306 # MySQL安装目录 basedir=D:\\Env\\mysql-8.4.0-winx64 # MySQL数据文件的存储目录，根据实际情况修改路径 datadir=D:\\Env\\mysql-8.4.0-winx64\\data # 设置MySQL使用的字符集，utf8mb4支持更多字符，建议使用 character-set-server=utf8mb4 # 设置默认的存储引擎，InnoDB是MySQL 8的默认且推荐的事务安全存储引擎 default-storage-engine=InnoDB # 控制InnoDB存储引擎使用的内存大小，根据服务器内存情况调整，一般设置为物理内存的50% - 80% innodb_buffer_pool_size = 1G # 控制InnoDB数据文件的大小增长策略，每次自动扩展的大小 innodb_autoextend_increment = 64M # 控制InnoDB存储引擎中日志文件的大小，影响事务处理性能和恢复时间 innodb_log_file_size = 256M # 允许的最大连接数，根据服务器性能和预计并发访问量调整 max_connections = 200 # 允许单个查询使用的最大临时表大小，防止查询生成过大的临时表耗尽内存 max_heap_table_size = 64M # 为了提高性能，可设置不区分大小写的表名（Windows系统下默认如此，Linux系统下需谨慎设置） lower_case_table_names = 1 [mysql] # 设置MySQL客户端默认使用的字符集，与服务器端保持一致 default-character-set=utf8mb4 [client] # 设置MySQL客户端连接服务器时使用的端口号，需与服务器端配置一致 port=3306 # 设置MySQL客户端默认使用的字符集，与服务器端保持一致 default-character-set=utf8mb4 启动命令 管理员身份运行，避免权限问题 # 初始化数据库 (随机 root 密码输出到控制台) mysqld --initialize --console # 安装服务 mysqld --install # 启动服务 net start mysql # 登录 mysql -u root -p # 修改密码 alter user 'root'@'localhost' identified by '新密码'; # 刷新权限 flush privileges; ","date":"2025-03-20","objectID":"/posts/mysql_config_and_command/:0:0","tags":["MySQL"],"title":"MySQL 8.0 解压安装版配置文件及参数命令","uri":"/posts/mysql_config_and_command/"},{"categories":["Golang"],"content":"在Go语言 json 处理领域，在 json 数据处理中，读取与修改是两个核心需求。前文介绍的 GJSON 解决了灵活读取问题，而 SJSON 作为其姊妹库，则专注于实现无需结构体定义的 json 动态修改。 本文将延续对比分析风格，解析 SJSON 的核心价值。 一、Go 原生 json 修改方式 Go 原生修改 json 数据，同样需先定义结构体，然后再将 json 数据解析到结构体实例，如： package main import ( \"encoding/json\" \"fmt\" ) type Person struct { Name string `json:\"name\"` Age int `json:\"age\"` } func main() { jsonStr := `{\"name\":\"张三\",\"age\":25}` var person Person err := json.Unmarshal([]byte(jsonStr), \u0026person) if err != nil { fmt.Println(\"解析错误:\", err) return } person.Age = 35 newJson, _ := json.Marshal(person) fmt.Println(string(newJson)) } 二、SJSON 组件 1.概述： SJSON 提供通过路径表达式直接修改 json 字符串的能力，与 GJSON 采用相同路径语法，形成读写闭环。 官网地址：GitHub - tidwall/sjson 2.安装： 使用 Go 的包管理工具 go get 安装 SJSON： go get -u github.com/tidwall/sjson 三、SJSON核心用法 1.基础值修改 package main import ( \"fmt\" \"github.com/tidwall/sjson\" ) func main() { jsonStr := `{\"name\":\"张三\",\"age\":25}` // 修改 age 值为 35 newJson, _ := sjson.Set(jsonStr, \"age\", 35) fmt.Println(string(newJson)) } 2.嵌套结构修改 package main import ( \"fmt\" \"github.com/tidwall/sjson\" ) func main() { jsonStr := `{ \"name\": \"张三\", \"age\": 25, \"hobby\": { \"sing\": \"只因你太美\", \"dance\": \"背带裤\", \"rap\": \"kun\", \"ball\": \"篮球\" }` // 修改 hobby.sing 的值: 只因你太美 =\u003e 重生 newJson, _ := sjson.Set(jsonStr, \"hobby.sing\", \"重生\") fmt.Println(string(newJson)) } 3.数组操作 package main import ( \"fmt\" \"github.com/tidwall/sjson\" ) func main() { jsonStr := `{\"hobby\": [\"sing\",\"dance\",\"rap\",\"ball\"]}` // 修改 hobby 数组第4个元素为 play newJson, _ := sjson.Set(jsonStr, \"hobby.3\", \"play\") fmt.Println(string(newJson)) // 追加 hobby 数组第5个元素为 play newJson, _ = sjson.Set(jsonStr, \"tags.-1\", \"play\") fmt.Println(string(newJson)) } 4.字段删除 package main import ( \"fmt\" \"github.com/tidwall/sjson\" ) func main() { jsonStr := `{\"name\":\"张三\",\"age\":25}` // 删除age字段 newJson, _ := sjson.Delete(jsonStr, \"age\") fmt.Println(string(newJson)) } 四、SJSON 与原生方案对比 SJSON 摆脱结构体定义束缚，保持原始 json 结构完整性，避免修改后丢失未定义字段的问题。 SJSON 路径直达修改位置，规避嵌套结构嵌套带来的问题，与 GJSON 组成完整处理链路。 SJSON 支持运行时动态路径构建，避免硬编码路径带来的问题。 ","date":"2025-03-09","objectID":"/posts/go_sjson_component/:0:0","tags":["Golang"],"title":"Go-SJSON 组件，JSON 动态修改新方案","uri":"/posts/go_sjson_component/"},{"categories":["Golang"],"content":"在 Go 语言开发领域，json 数据处理是极为常见的任务。Go 标准库提供了 encoding/json 包用于处理 json 数据，同时第三方库 GJSON \u0026 SJSON 也在 json 处理方面表现出色。 本文将深入探讨下 GJSON 组件，通过与原生处理方式对比，它存在什么特别之处，它的优势体现在哪。 一、Go 原生 json 读取方式 Go 原生读取 json 数据，通常需先定义结构体，然后再将 json 数据解析到结构体实例，如： { \"name\": \"张三\", \"age\": 25 } 具体处理逻辑： package main import ( \"encoding/json\" \"fmt\" ) type Person struct { Name string `json:\"name\"` Age int `json:\"age\"` } func main() { jsonStr := `{\"name\":\"张三\",\"age\":25}` var person Person err := json.Unmarshal([]byte(jsonStr), \u0026person) if err!= nil { fmt.Println(\"解析错误:\", err) return } fmt.Println(\"Name:\", person.Name) fmt.Println(\"Age:\", person.Age) } 这种方式虽能准确解析 json 数据，但如果 json 存在多层嵌套，层级过度包装，那么结构体定义以及解析过程就会变得相当繁琐。 二、GJSON 组件 1.概述： GJSON 是一个轻量级且高性能的 JSON 解析库，它允许开发者通过简洁的语法，无需定义结构体，就能快速提取 JSON 数据中的特定值。 官网地址：GitHub - tidwall/gjson 2.安装： 使用 Go 的包管理工具 go get 安装 GJSON： go get -u github.com/tidwall/gjson 三、GJSON 基本用法 1.简单 json 数据获取 对于简单的 json，像前面那个例子，直接用 gjson.Get 方法，传入 json 字符串和要获取的字段名，就能拿到对应的值。比如获取 name 字段，gjson.Get(jsonStr, \"name\") 就可以搞定，例如： package main import ( \"fmt\" \"github.com/tidwall/gjson\" ) func main() { jsonStr := `{\"name\":\"张三\",\"age\":25}` name := gjson.Get(jsonStr, \"name\") age := gjson.Get(jsonStr, \"age\") fmt.Println(\"Name:\", name.String()) fmt.Println(\"Age:\", age.Int()) } 2.嵌套 json 数据获取 上述提到，原生的处理方式对于多层级的 json 很不友好，然而 gjon 可以直接通过点号分隔路径定位数据，这时候它的优势就逐渐明显，例如： { \"name\": \"张三\", \"age\": 25, \"hobby\": { \"sing\": \"只因你太美\", \"dance\": \"背带裤\", \"rap\": \"kun\", \"ball\": \"篮球\" } } 具体处理逻辑： package main import ( \"fmt\" \"github.com/tidwall/gjson\" ) func main() { jsonStr := `{ \"name\": \"张三\", \"age\": 25, \"hobby\": { \"sing\": \"只因你太美\", \"dance\": \"背带裤\", \"rap\": \"kun\", \"ball\": \"篮球\" }` name := gjson.Get(jsonStr, \"name\") ball := gjson.Get(jsonStr, \"hobby.ball\") fmt.Println(\"Name:\", name.String()) fmt.Println(\"ball:\", ball.String()) } 相比原生方式，无需复杂结构体定义，操作更简便。 3. json 数组获取 如果在 json 中嵌套了数组，对于这种的处理也比较简单，直接通过数组下标来定位数据即可，如： package main import ( \"fmt\" \"github.com/tidwall/gjson\" ) func main() { jsonStr := `{\"hobby\": [\"sing\",\"dance\",\"rap\",\"ball\"]}` hobby := gjson.Get(jsonStr, \"hobby.3\") // 输出第4个爱好 fmt.Println(\"hobby:\", hobby.String()) } 相比于原生方式处理数组，得先解析成切片，操作起来就没这么直接。 四、GJSON 与原生 JSON 处理方式对比 GJSON 语法简单直观，熟悉 json 结构即可快速上手，无需学习结构体定义及标签使用等知识。而原生方式在结构体定义上相对复杂，尤其是处理复杂 json 结构时。 GJSON 无需将整个 json 数据解析为结构体，在处理大型 json 数据时，内存占用少，解析速度快。原生方式在解析复杂 json 数据时，结构体构建和内存分配开销较大。 GJSON 对各种复杂 json 结构都能灵活应对，根据需求按路径获取数据，无需频繁修改代码结构。原生方式则需根据 json 结构变化，频繁修改结构体定义，灵活性较差。 ","date":"2025-03-02","objectID":"/posts/go_gjson_component/:0:0","tags":["Golang"],"title":"Go-GJSON 组件，解锁 JSON 读取新姿势","uri":"/posts/go_gjson_component/"},{"categories":["其他"],"content":" 最近 AI 大模型的热度可谓是如火如荼，尤其是国内的 DeepSeek 名闻遐迩，因其与 OpenAI 的模型相比，DeepSeek 推理大模型 R1 的训练成本仅为其 3%-5%‌ ，直接导致英伟达公司股票短时间内大跌。 此时我就比较好奇，为什么大模型训练中更多的是依赖 GPU，而不是 CPU 呢？ 随后这两天网上翻阅了些资料，也询问 AI 帮忙解答，大体总结出如下几点： 一、并行计算能力 GPU 具有高度并行的架构，能够同时处理大量的数据和计算任务。比如在进行矩阵运算时，它可以同时对多个元素进行操作，瞬间完成复杂的计算。 相比之下，CPU 虽然在串行计算方面表现不错，但并行处理能力相对较弱，无法像 GPU 那样同时处理众多任务。 二、内存带宽 大模型训练需要处理的数据量巨大，比如 DeepSeek R1 满血版参数就高达 671B （6710亿）这对内存带宽要求极高。 GPU 配备了超高的内存带宽，就类似拥有一条宽阔的高速公路，数据可以快速地传输到计算核心进行处理。 而 CPU 的内存带宽则相对有限，面对海量数据时，就像走在狭窄的小道上，容易形成数据传输的瓶颈，拖慢训练速度。 三、浮点运算性能 在大模型训练中，离不开浮点运算。 GPU 在浮点运算性能方面优势明显，它拥有大量的浮点运算单元，能够在单位时间内执行海量的浮点运算操作。 CPU 的浮点运算能力相对较弱，在处理大规模的浮点运算时，效率远远比不上 GPU 。 四、深度学习框架支持 现在主流的深度学习框架，像是 TensorFlow 和 PyTorch 等，都对 GPU 进行了深度优化和兼容，能够充分发挥其强大的性能，自动将计算任务合理分配到 GPU 上并行执行。 然而，对于 CPU 的优化就没那么给力，导致在实际训练中，使用 CPU 的效果不尽如人意。 五、能耗效率 常理来看 GPU 功耗好像挺高，但从单位时间完成的计算量来看，它的能耗效率还是可以的。 虽然 CPU 功耗低，但完成相同的训练任务需要更长时间，综合能耗并不占优势。 六、成本效益 GPU 单价相比 CPU 确实较高，但是它能大幅缩短训练时间。有句话说的好，时间就是金钱！这样算下来，总体的成本反而更低。 而 CPU 训练时间长，资源占用和维护成本累加起来也不少。 所以，综合以上这些方面看，GPU 在大模型训练中脱颖而出，而 CPU 则在这个领域就有点力不从心了。 ","date":"2025-02-15","objectID":"/posts/why_does_ai_training_rely_on_gpus_instead_of_cpus/:0:0","tags":["AI"],"title":"为什么大模型训练依赖 GPU 而不是 CPU","uri":"/posts/why_does_ai_training_rely_on_gpus_instead_of_cpus/"},{"categories":["Golang"],"content":"在 Go 项目开发中，有效的异常处理是确保程序健壮性和稳定性的关键因素之一。全局异常处理机制能够统一处理项目中可能出现的各种异常情况，提高代码的可读性、可维护性以及错误处理的一致性。 一、Go 中的错误处理机制 在 Go 语言中，并没有像其他语言那样的传统异常机制。而是期望开发者主动去识别处理这种“异常”，通过返回值来表示可能出现的错误。 通常情况下，函数会返回一个结果集和一个错误值，我们需要判断错误值是否为 nil，如果不为 nil 则表示出现了“异常”。 package main import ( \"fmt\" ) // 模拟一个会返回错误的函数 func divide(a, b int) (int, error) { if b == 0 { return 0, fmt.Errorf(\"除数不能为 0\") } return a / b, nil } func main() { result, err := divide(10, 0) if err != nil { fmt.Println(\"出错啦:\", err) return } fmt.Println(\"结果是:\", result) } 二、Go 中的 panic 当程序遇到无法处理的错误时，就会被提示panic，程序会直接崩溃。 recover 函数用于捕获 panic 抛出的信息，让程序从 panic 状态恢复继续正常执行，前提 recover 只能在 defer 函数中使用。 package main import ( \"fmt\" ) func main() { defer func() { if r := recover(); r != nil { fmt.Println(\"已捕获到恐慌:\", r) } }() // 手动触发一个 panic panic(\"这是一个恐慌！\") } // 输出： // 已捕获到恐慌:这是一个恐慌！ 三、实现全局异常处理 根据上述其实不难发现，错误处理是显式的，我们可以做前置判断，根据具体情况进行处理，但是panic 处理通常是隐式的，一旦被调用 panic 函数，程序的执行流程会被打乱，需捕获 panic 才能恢复程序的正常执行。 所以针对这种隐式的、在编程过程中无法提前预知的错误，就很有必要做一层异常的处理，最好可以是全局处理。 为了实现全局异常处理，我们可以创建一个中间件或者全局的异常处理函数。 func GlobalErrorHandler() gin.HandlerFunc { return func(c *gin.Context) { defer func() { if err := recover(); err!= nil { log.Printf(\"Recovered from panic: %v\", err) c.JSON(500, gin.H{ \"message\": \"Internal Server Error\", }) c.Abort() } }() c.Next() } } 四、在项目中的应用 在实际的项目中，我们可以将这个全局异常处理中间件应用到 HTTP 服务器的路由处理中。 package main import ( \"github.com/gin-gonic/gin\" \"log\" ) func main() { r := gin.Default() // 应用全局异常处理中间件 r.Use(GlobalErrorHandler()) r.GET(\"/ping\", func(c *gin.Context) { // 模拟异常 panic(\"Something went wrong!\") }) r.Run(\":8080\") } 这样下来，在程序的后续处理中，一旦遇到 panic 就会被捕获，从而不影响程序的继续运行。 ","date":"2025-02-09","objectID":"/posts/go_practical_global_exception_handling/:0:0","tags":["Golang","Gin","Panic"],"title":"Go 项目实战：全局异常处理","uri":"/posts/go_practical_global_exception_handling/"},{"categories":["Golang"],"content":"在 Web 项目的开发过程中，能够在不同的环境（如开发、测试、生产）中进行灵活部署是至关重要的。不同环境通常需要不同的配置，如服务器端口、数据库连接信息、缓存设置等。 对于 Java 的 SpringBoot 框架来说，可以直接在 application.yml 中指定一个环境配置文件，通常application_dev.yml 代表开发环境，那么 go 可否参考这种方式呢？ 接下来本文将详细介绍如何使用多种方式来实现多环境开发部署，重点围绕 config.yaml 文件和 config.go 文件来进行配置读取和环境区分。 Go 中的系统环境变量 先来解释一个概念，在 Go 语言中，系统环境变量是操作系统为每个进程提供的键值对集合。这些环境变量可以用于配置应用程序的行为、连接数据库、设置日志级别等。Go 提供了标准库 os 来读取和操作这些环境变量。 实战 1.编写.env文件 在项目根目录下新建一个 .env 文件，配置如下： APP_ENV=dev 2.获取环境变量 使用 os.Getenv 函数可以获取指定名称的环境变量值。 env := os.Getenv(\"APP_ENV\") APP_ENV 是一个环境变量名，用于标识应用程序的运行环境（如开发、测试、生产等）。 如果 APP_ENV 未设置，os.Getenv(\"APP_ENV\") 将返回空字符串。 3.设置默认值 我们需要一个默认的环境，如果 APP_ENV 未设置，将其设为 \"dev\"： env := os.Getenv(\"APP_ENV\") if env == \"\" { env = \"dev\" // 默认环境为 dev } 这样可以确保即使没有显式设置 APP_ENV，程序也能有一个合理的默认行为。 4.加载 .env 文件 使用 github.com/joho/godotenv 包来加载 .env 文件中的环境变量。.env 文件通常用于本地开发环境，避免将敏感信息硬编码到代码中，这里其实挺像 vue 的环境加载方式。 err := godotenv.Load() if err != nil { return fmt.Errorf(\"加载 .env 文件失败: %v\", err) } 这行代码会读取项目根目录下的 .env 文件，并将其中定义的环境变量加载到当前进程中。 5.动态选择配置文件 根据 APP_ENV 的值，动态选择不同的配置文件： viper.AddConfigPath(\"./config\") viper.SetConfigName(fmt.Sprintf(\"config_%s\", env)) viper.SetConfigType(\"yaml\") err = viper.ReadInConfig() if err != nil { return fmt.Errorf(\"读取配置文件失败: %v\", err) } 这段代码会根据 APP_ENV 的值（例如 dev 或 production），选择对应的配置文件（如 config_dev.yaml 或 config_prod.yaml）。这样可以根据不同的环境加载不同的配置。 6.解析配置文件 使用 viper.Unmarshal 将配置文件的内容解析到结构体中： Conf = \u0026Config{} err = viper.Unmarshal(Conf) if err != nil { return fmt.Errorf(\"解析配置文件失败: %v\", err) } viper.Unmarshal 会将配置文件中的键值对映射到结构体字段上，前提是结构体字段标签（如 yaml 和 mapstructure）与配置文件中的键匹配。 通过上述方式，我们可以根据项目的实际需求和情况，确保项目在不同环境下都能正确配置并稳定运行。 ","date":"2025-01-25","objectID":"/posts/go_practical_multi_environment_development/:0:0","tags":["Golang","Gin"],"title":"Go 项目实战：如何部署多环境开发","uri":"/posts/go_practical_multi_environment_development/"},{"categories":["Golang"],"content":"在 Go 项目开发中，日志处理是一项至关重要的任务。它不仅有助于我们在开发过程中调试代码，还能在生产环境中帮助我们快速定位问题。本文将详细介绍如何在 Go 项目中优雅地处理日志，包括日志的级别、格式、输出以及如何使用第三方日志库等方面。 一、日志级别的重要性 日志级别是控制日志输出的重要手段。通过设置不同的日志级别，我们可以灵活地控制日志的详细程度。在 Go 语言中，常见的日志级别有DEBUG、INFO、WARN、ERROR和FATAL。不同级别的日志用于记录不同类型的信息，例如： DEBUG：用于记录详细的调试信息，仅在开发环境中启用。 INFO：用于记录正常的业务流程信息，例如请求的处理、数据的加载等。 WARN：用于记录可能存在的问题或异常情况，但不影响系统的正常运行。 ERROR：用于记录严重的错误信息，这些错误可能导致系统无法正常运行。 FATAL：用于记录非常严重的错误信息，这些错误会导致程序立即退出。 二、日志格式的选择 日志格式的选择对于日志的可读性和分析性至关重要。一个好的日志格式应该包含足够的信息，以便我们能够快速定位问题。常见的日志格式有 JSON、XML 和文本格式等。 在 Go 语言中，我们可以使用第三方库来实现不同的日志格式。例如，使用 logrus 库可以轻松地将日志格式化为 JSON 格式： package main import ( \"github.com/sirupsen/logrus\" ) func main() { // 设置日志格式为JSON logrus.SetFormatter(\u0026logrus.JSONFormatter{}) // 记录不同级别的日志 logrus.Debug(\"这是一条DEBUG级别的日志\") logrus.Info(\"这是一条INFO级别的日志\") logrus.Warn(\"这是一条WARN级别的日志\") logrus.Error(\"这是一条ERROR级别的日志\") logrus.Fatal(\"这是一条FATAL级别的日志\") } 三、日志输出的方式 日志输出的方式有很多种，例如输出到控制台、文件、数据库等。在 Go 语言中，我们可以使用标准库的log包来实现基本的日志输出功能。例如，使用标准库 log.Println 方法可以将日志输出到控制台： package main import \"log\" func main() { // 记录日志到控制台 log.Println(\"这是一条日志信息\") } 如果需要将日志输出到文件，我们可以这么做： package main import ( \"log\" \"os\" ) func main() { // 创建日志文件 file, err := os.OpenFile(\"app.log\", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644) if err != nil { log.Fatal(err) } defer file.Close() // 设置日志输出到文件 log.SetOutput(file) // 记录日志 log.Println(\"这是一条日志信息\") } 除了常见的输出到控制台或指定文件，我们还可以将日志输出到数据库、Elasticsearch 等其他存储介质中。具体的实现方式还需根据实际需求进行选择。 四、使用第三方日志库 虽然说 Go 语言的标准库提供了基本的日志处理功能，但在实际项目中，往往需要结合第三方更为强大的库来满足日常需求： logrus：一个功能强大的日志库，支持多种日志格式、日志级别、日志输出方式等。 zap：一个高性能的日志库，具有快速、灵活、可扩展等特点。 zerolog：一个极简主义的日志库，专注于提供高性能和简单的 API。 ps: 上述简介来自于AI，注意甄别 这些第三方日志库都提供了丰富的功能和灵活的配置选项，可以帮助我们更好地处理日志。在这里个人比较推荐 logrus ，不过具体需求还是得具体选择。 五、实战 介绍再多也是空谈，接下来结合具体的项目，我们优雅的配置一下。 默认项目已经安装 logrus ，没有的话可以执行下如下命令： go get github.com/sirupsen/logrus 1.配置config.yaml 为了方便随时更改切换 log 级别或者输出格式，我们可以单独抽离出来实现配置化： log: format: json # 输出格式 level: debug # 日志级别 report_caller: true # 是否开启调试 2.配置config.go 有了参数配置，还缺一步解析： 具体的解析可以参考 Go 项目实战：搭建高效的 Gin Web 目录结构 3.新建logger.go 在这里我们统一配置 logrus 参数，包括日志级别，输出格式： package app import ( log \"github.com/sirupsen/logrus\" ) // InitializeLogger 设置日志输出 func InitializeLogger() error { // 设置日志格式 switch config.Conf.Log.Format { case \"json\": log.SetFormatter(\u0026log.JSONFormatter{}) case \"text\": log.SetFormatter(\u0026log.TextFormatter{}) default: log.SetFormatter(\u0026log.JSONFormatter{}) } // 设置日志级别 switch config.Conf.Log.Level { case \"debug\": log.SetLevel(log.DebugLevel) case \"info\": log.SetLevel(log.InfoLevel) case \"warn\": log.SetLevel(log.WarnLevel) case \"error\": log.SetLevel(log.ErrorLevel) case \"fatal\": log.SetLevel(log.FatalLevel) case \"panic\": log.SetLevel(log.PanicLevel) default: log.SetLevel(log.InfoLevel) } // 设置打印调用信息 log.SetReportCaller(config.Conf.Log.ReportCaller) return nil } 4.输出日志到文件 控制台打印日志，肯定是不满足一个项目的正常使用的，我们非常有必要将日志持久化到一个单独文件中。 但是这样还不够，会存在另一个问题：日志文件会越来越大后期不利于日志排查。所以还需要对日志进行一个分割，最好的实践方式就是按天分割，所以我们接着在上述初始化文件中去做设置： package app import ( \"os\" \"time\" \"github.com/lestrrat-go/file-rotatelogs\" log \"github.com/sirupsen/logrus\" \"your_project/config\" ) // InitializeLogger 设置日志输出并初始化日志文件 func InitializeLogger() error { // 设置日志格式 ... // 设置日志级别 ... // 设置打印调用信息 ... // 创建日志目录 logDir := \"../logs\" err := os.MkdirAll(logDir, 0755) if err != nil { log.Fatalf(\"创建日志目录失败: %v\", err) } // 设置日志输出，按天切割 logFilePath := logDir + \"/app.%Y%m%d.log\" writer, err := rotatelogs.New( logFilePath, rotatelogs.WithLinkName(logDir+\"/app.log\"), rotatelogs.WithMaxAge(7*24*time.Hour), // 保留7天 rotatelogs.WithRotationTime(24*time.Hour), // 每天切割一次 ) if err != nil { log.Fatalf(\"设置日志输出失败: %v\", err) } log.SetOutput(writer) return nil } 5.调用InitializeLogger() package main import ( \"fmt\" \"github.com/gin-gonic/gin\" log \"github.com/sirupsen/logrus\" \"your_project/config\" \"your_project/internal/api/v1\" \"your_project/internal/app\" ) func main() { // 加载配置文件 err := config.LoadConfig() if err != nil { log.Error(\"配置文件加载错误: %v\", err) return } // 初始化 logger err = InitializeLogger() if err != nil { log.Error(\"logger 初始化错误: %v\", err) return } r := gin.Default() v1.Setu","date":"2025-01-22","objectID":"/posts/go_practical_processing_log/:0:0","tags":["Golang","Gin"],"title":"Go 项目实战：如何优雅的处理日志","uri":"/posts/go_practical_processing_log/"},{"categories":["Golang"],"content":"引言 在当今迅速迭代的软件开发领域，挑选合适的工具与框架对于项目能否顺利推进至关重要。Gin 框架，作为 Go 语言生态中备受青睐的 Web 开发框架，凭借其卓越的性能、简洁的设计以及丰富的功能特性，在众多选项中脱颖而出。本文旨在深入剖析如何在使用 Gin 框架的过程中，构建一个既高效又便于管理的项目架构，助力开发者打造既快速响应又易于维护的 Web 应用程序。 一、Gin 概述 引入官网的描述：Gin 是一个使用 Go 语言开发的 Web 框架。 它提供类似 Martini 的 API，但性能更佳，速度提升高达40倍。 如果你是性能和高效的追求者, 你会爱上 Gin。 对比 Beego 框架，Gin 框架采用了极简主义的方法，为追求简单和高性能，没有多余文件或目录，他甚至什么也没有，没有集成任何中间件，一个 main 文件即可启动一个web服务。 正因为如上所述，过分精简对于开发一个项目来说，前期的项目搭建工作就显得尤为重要。 二、项目结构设计 有过 Java 开发经验的伙伴应该了解，SpringBoot 遵循着 MVC 的设计理念，这一套设计理念一直沿用至今，他的优秀难以言喻，Gin 框架完全可以参照这个模式来做，如下是我个人设计的一套架构： ├── /cmd │ └── main.go ├── /configs │ └── config.yaml ├── /docs ├── /internal │ ├── /api │ │ ├── v1 │ │ │ ├── /routes.go │ ├── /app │ │ ├── bootstrap.go │ │ ├── config.go │ │ ├── db.go │ │ └── ... │ ├── /controller │ │ ├── user_controller.go │ │ └── ... │ ├── /middleware │ │ ├── error.go │ │ └── ... │ ├── /model │ │ ├── user_entity.go │ │ └── ... │ ├── /repository │ │ ├── user_repository.go │ │ └── ... │ ├── /service │ │ ├── user_service.go │ │ └── ... │ └── /utils ├── /pkg ├── /scripts ├── /tests ├── .env ├── go.mod ├── go.sum 三、目录职责 /cmd 存放应用的入口文件。 main.go：是整个应用的入口，在这里启动应用。 /configs 存放应用的配置文件和配置加载逻辑。 config.yaml：应用的配置文件，通常包含数据库连接信息、服务器设置等。 /docs 存放应用的文档，如API文档、用户手册等。 /internal 存放应用的内部逻辑，这些代码不能被外部包所引入，可根据实际需求进而拆分目录。 api：包含应用中核心的业务路由等，即URL路径与控制器方法的映射。 app：包含应用的核心逻辑，如初始化、启动等。 controller：包含控制器逻辑，处理请求并返回响应。 middleware：存放中间件代码，用于在请求处理流程中的特定阶段执行代码。 model：定义应用的数据模型，通常与数据库表结构对应。 repository：实现数据访问逻辑，与数据库进行交互。 service：实现业务逻辑，调用repository中的方法来处理业务需求。 utils：包含通用的工具函数，这些函数可以被多个包所共享。 /pkg 存放第三方库，如第三方中间件、工具库等。 /scripts 存放各种脚本，如项目部署脚本、测试脚本等。 /tests 存放测试代码，包括单元测试、集成测试等。 这里的目录结构可以根据需要自行组织，以支持不同类型的测试。 以上目录结构有助于清晰地分离应用的不同部分，使得代码更加模块化、易于理解和维护。同时，我也参照众多优秀开源项目的目录搭建思想，使其完美遵循了 Go 语言的最佳实践。 四、实战 目录搭建好后，开始填充代码 下边简单实现集成数据库，配置路由，启动服务 1.配置config 在 config.yaml 文件下配置端口和数据库连接，这里选择xorm： # 基础配置 app: port: 8080 database: driver: mysql source: root:123456@tcp(127.0.0.1:3306)/xxx_table?charset=utf8mb4\u0026parseTime=True\u0026loc=Local 在 config.go 下解析配置 package config import ( \"fmt\" \"github.com/spf13/viper\" ) type Config struct { App AppConfig `yaml:\"app\" mapstructure:\"app\"` Database DatabaseConfig `yaml:\"database\" mapstructure:\"database\"` } type AppConfig struct { Port int `mapstructure:\"port\"` } type DatabaseConfig struct { Driver string `yaml:\"driver\" mapstructure:\"driver\"` Source string `yaml:\"source\" mapstructure:\"source\"` } var Conf *Config // LoadConfig 加载配置文件 func LoadConfig() error { // 设置配置文件路径和名称 viper.AddConfigPath(\"./configs\") viper.SetConfigName(\"config\") viper.SetConfigType(\"yaml\") // 读取配置文件 err = viper.ReadInConfig() if err != nil { return fmt.Errorf(\"读取配置文件失败: %v\", err) } // 将配置文件内容解析到 Conf 变量中 Conf = \u0026Config{} err = viper.Unmarshal(Conf) if err != nil { return fmt.Errorf(\"解析配置文件失败: %v\", err) } return nil } 2.配置init 数据库及其他的初始化统一放置到 app 目录下，在这里新建 loader.go 来初始化 mysql，但是为了之后方便管理，我们另单独创建 db.go 文件： 如需要加载其他如 redis，那就新建 redis.go 文件 package app import ( _ \"github.com/go-sql-driver/mysql\" \"github.com/go-xorm/xorm\" log \"github.com/sirupsen/logrus\" \"yourProject/config\" ) var Engine *xorm.Engine // InitializeMySQL 数据库初始化 func InitializeMySQL() error { var err error // 创建数据库引擎 Engine, err = xorm.NewEngine(config.Conf.Database.Driver, config.Conf.Database.Source) if err != nil { log.Error(\"数据库初始化失败: %v\", err) return err } // 测试数据库连接 if err = Engine.Ping(); err != nil { log.Error(\"数据库连接失败: %v\", err) return err } return nil } app.go 中调用 InitializeMySQL() package app import ( \"fmt\" ) // InitializeAll 初始化所有模块 func InitializeAll() error { err := InitializeMySQL() if err != nil { return fmt.Errorf(\"MySQL初始化错误: %v\", err) } return nil } 3.配置model 在 model 下新建 user_entity.go，注意：这个需要和数据库对应 package model type User struct { Id int64 `xorm:\"pk autoincr 'id'\"` UserID int64 `xorm:\"not null 'user_id'\"` Password string `xorm:\"varchar(50) not null 'password'\"` UserName string `xorm:\"varchar(30) 'user_name'\"` Email string `xorm:\"varchar(50) 'email'\"` PhoneNumber int64 `xorm:\"'phone_number'\"` Sex string `xorm:\"char(1) 'sex'\"` Remark string `xorm:\"varchar(500) 'remark'\"","date":"2025-01-19","objectID":"/posts/go_practical_gin_directory_structure/:0:0","tags":["Golang","Gin"],"title":"Go 项目实战：搭建高效的 Gin Web 目录结构","uri":"/posts/go_practical_gin_directory_structure/"},{"categories":null,"content":"欢迎留下你的声音 “无论你有什么想法，这里永远有倾听的耳朵” —— 留言板寄语 ","date":"2025-01-14","objectID":"/message/:0:0","tags":null,"title":"留言板","uri":"/message/"},{"categories":["Golang"],"content":"首先我们先明确下 json 包下 Unmarshal() 函数是什么： 它是 Go 语言标准库 encoding/json 中的一个函数，用于将 JSON 数据解析为 Go 语言中的数据结构。它的作用是将一个 JSON 格式的字节切片（[]byte）转换为对应的 Go 语言数据类型，如结构体、切片、映射等。 其次了解了它的作用后，再来看下这个坑点： 假设有一个 json 串如下： { \"id\": 1, \"name\": \"张三\", \"age\": 20 } 现在要将它解析成一个 map，拿到 json 原始的数据，方便后续处理： func main() { str := \"{\\\"id\\\":1,\\\"name\\\":\\\"张三\\\",\\\"age\\\":20}\" jsonMap := make(map[string]interface{}) json.Unmarshal([]byte(str), \u0026amp;jsonMap) // 遍历map for key, value := range jsonMap { fmt.Printf(\"key: %s, value: %v\\n\", key, value) } } // 输出： // key: id, value: 1 // key: name, value: 张三 // key: age, value: 20 这样看着确实没什么问题，每个 key、value 值都是按照预期输出； 现在我把 json 调整一下，假设 id 是一个毫秒级时间戳 1736325205000（13 位）： func main() { str := \"{\\\"id\\\":1736325205000,\\\"name\\\":\\\"张三\\\",\\\"age\\\":20}\" jsonMap := make(map[string]interface{}) json.Unmarshal([]byte(str), \u0026amp;jsonMap) // 遍历map for key, value := range jsonMap { fmt.Printf(\"key: %s, value: %v\\n\", key, value) } } // 输出 // key: id, value: 1.736325205e+12 // key: name, value: 张三 // key: age, value: 20 此时坑来了， id 的值变成了一个科学计数法的字符串，显然这不符合我的预期； 那么为什么会变成这样呢？ 首先观察到我使用了 %v 进行处理，然而 json 中原本的数据是一个 int，我应该用处理 int 的占位符 %d ： func main() { str := \"{\\\"id\\\":1736325205000,\\\"name\\\":\\\"张三\\\",\\\"age\\\":20}\" jsonMap := make(map[string]interface{) json.Unmarshal([]byte(str), \u0026amp;jsonMap) fmt.Printf(\"%d\",jsonMap[\"id\"]) } // 输出 // %!d(float64=1.736325205e+12) 到这里本以为是 ok 的，结果输出了这么个玩意，仔细读一下发现 float64 ，输出这个的原因是我要把一个 float64 的元素强行用 int 类型的占位符进行处理； 所以现在进一步清晰了，json.Unmarshal 函数会把 id 转为 float64； 那么问题又来了，为什么它会把 id 转为 float64 类型呢？id == 1 的时候为什么能正常输出呢？ 进源码，看看函数内部做了什么： func Unmarshal(data []byte, v any) error { // Check for well-formedness. // Avoids filling out half a data structure // before discovering a JSON syntax error. var d decodeState err := checkValid(data, \u0026amp;d.scan) if err != nil { return err } d.init(data) return d.unmarshal(v) } // 可以看到 checkValid() 方法引用了 decodeState 结构体 // 进结构体里看下： // decodeState represents the state while decoding a JSON value. type decodeState struct { data []byte off int // next read offset in data opcode int // last read result scan scanner errorContext *errorContext savedError error useNumber bool disallowUnknownFields bool } // 初步观察有个 bool 类型的 useNumber 属性 // 接着看下这个结构体具体的实现方法： // convertNumber converts the number literal s to a float64 or a Number // depending on the setting of d.useNumber. func (d *decodeState) convertNumber(s string) (any, error) { if d.useNumber { return Number(s), nil } f, err := strconv.ParseFloat(s, 64) if err != nil { return nil, \u0026amp;UnmarshalTypeError{Value: \"number \" + s, Type: reflect.TypeOf(0.0), Offset: int64(d.off)} } return f, nil } // 到这里大概能清楚，是这个方法把我的 id 转成了 float64，但是再转之前还有一层 if 会把原始值输出； // 接下来就回去上一级，看看 d.scan 到底做了什么： // 努力中... // ——————看不懂 经过多方查找： 理论上 json 会把超过 int64 长度的数值转成 float64，但是这个说法经实践不成立，毫秒级时间戳 13 位，远没有超过 int64 的最大长度； 多次翻阅资料后，有一个说法比较靠谱： 当处理非常大的整数（如毫秒级的时间戳）时，如果直接使用 Go 语言中的整数类型（如 int 或 int64），可能会因为超出这些类型的表示范围而导致溢出。虽然 int64 类型在大多数情况下可以容纳毫秒级的时间戳，但为了确保能够处理所有可能的 JSON 数字，encoding/json 包选择了 float64 类型作为默认解析结果。 到这里其实我们最初的目的也能够轻松处理： func main() { str := \"{\\\"id\\\":1736325205000,\\\"name\\\":\\\"张三\\\",\\\"age\\\":20}\" jsonMap := make(map[string]interface{}) json.Unmarshal([]byte(str), \u0026amp;jsonMap) // 断言类型为 float64 fmt.Println(jsonMap[\"id\"]) if f, ok := jsonMap[\"id\"].(float64); ok { fmt.Println(int(f)) } } // 输出 // 1736325205000 ","date":"2025-01-12","objectID":"/posts/json_unmarshall_parsing_numeric_types/:0:0","tags":["Golang"],"title":"Json.Unmarshal 解析数值类型（踩坑）","uri":"/posts/json_unmarshall_parsing_numeric_types/"},{"categories":["Golang"],"content":"高效地处理多个数据源并将其整合为有意义的结果是开发中一项重要的任务。Go 语言，以其强大的并发特性，为我们提供了优雅而高效的解决方案。那么我们探讨一下如何利用 Go 语言的协程，同时调用多个接口获取数据，并将这些数据无缝地合并为一个完整的数据集。 先假定一个场景： 现有一需求，需要请求n个接口（暂定为3个）获取接口数据，然后对数据进行二次处理并返回。 按照过往的经验，我们会依次请求接口拿到数据暂存，最后对数据进行包装处理，这种自上而下的处理方式其实并无不妥，现在想要提高下效率，利用牺牲 cpu 资源来换取查询性能。 先模拟创建几个接口，分别返回(k1，v1)、(k2，v2)、(k3，v4)： // 模拟接口A func getDataFromA() map[string]interface{} { return map[string]interface{}{ \"key1\": \"value1\", } } // 模拟接口B func getDataFromB() map[string]interface{} { return map[string]interface{}{ \"key2\": \"value2\", } } // 模拟接口C func getDataFromC() map[string]interface{} { return map[string]interface{}{ \"key3\": \"value3\", } } 开启协程分别请求上述接口： 首先得思考一个问题，协程执行不保证顺序，请求到的数据应该怎么保存？怎么判断全部协程都执行完毕？怎么拿到全部的数据？ 上述接口定义中返回的数据均是map，那么我完全可以用map来保存数据，所以我定义方法就可以这么定义： func getAllData() map[string]interface{} { return nil // 暂时先不做处理 } 为了防止主协程先于其他执行结束，需要引入 sync.WaitGroup 包控制；所有协程返回的数据，可以用通道来暂存，make 一个容量为 3 的 channel： func getAllData() map[string]interface{} { var wg sync.WaitGroup resultChan := make(chan map[string]interface{}, 3) return nil // 暂时先不做处理 } 接下来就可以开启协程去调用: func getAllData() map[string]interface{} { var wg sync.WaitGroup resultChan := make(chan map[string]interface{}, 3) wg.Add(3) go func() { defer wg.Done() resultChan \u003c- getDataFromA() }() go func() { defer wg.Done() resultChan \u003c- getDataFromB() }() go func() { defer wg.Done() resultChan \u003c- getDataFromC() }() wg.Wait() close(resultChan) return nil // 暂时先不做处理 } 最后可以对数据做个简单处理，封装成一个大map返回，实际业务当然按需处理： newMap := make(map[string]interface{}) for res := range resultChan { for k, v := range res { newMap [k] = v } } return newMap 执行验证返回结果： \u003e [Running] go run \"main.go\" \u003e map[key1:value1 key2:value2 key3:value3] ","date":"2025-01-12","objectID":"/posts/collaborative_processing_of_multiple_interfaces/:0:0","tags":["Golang","并发","协程"],"title":"Go 语言并发实战：利用协程处理多个接口数据","uri":"/posts/collaborative_processing_of_multiple_interfaces/"},{"categories":["Golang"],"content":"在如今的编程领域，一个程序能够同时处理多个任务的能力非常重要，而 Golang 在并发编程方面表现十分出色，具有很多独特的优势。 一、轻量级的协程（Goroutine） 在传统的像 Java 这样的编程语言中，创建线程来实现并发往往需要较大的资源开销和复杂的管理。但在 Golang 里，有了 Goroutine 就截然不同。 Goroutine 的创建几乎不费力气，我们可以毫无压力地同时启动成千上万的 Goroutine 来完成不同的任务，而且不用担心资源被大量消耗。 举个例子： package main import ( \"fmt\" \"time\" ) func task() { fmt.Println(\"Hello Goroutine!\") } func main() { go task() time.Sleep(1 * time.Second) } 在这段代码里，我们用 go task() 轻松地启动了一个 Goroutine 去执行 task 函数。 当然这样可能更直观： package main import ( \"fmt\" \"time\" ) func main() { go func() { fmt.Println(\"Hello Goroutine!\") }() time.Sleep(1 * time.Second) } 二、高效的通道（Channel） 在并发编程中，不同的任务之间需要数据通信，Golang 提供了一种更为直观和易于理解的方式来处理并发，Goroutine 和 Channel 的组合使用。 1.Goroutine \u0026 Channel 协作流程 package main import \"fmt\" func main() { ch := make(chan int) // 无缓冲的通道 go func() { ch \u003c- 1 }() num := \u003c-ch fmt.Println(num) } 通过这个通道ch，我们成功地在两个不同的 Goroutine 之间传递了数据。 优势： 无锁通信：Channel 内部基于循环队列和互斥锁实现，但开发者无需感知 同步简化：无缓冲 Channel 天然实现\"发送-接收\"原子操作，替代 WaitGroup 流水线模式：多级 Channel 串联可构建生产者-消费者管道 2.错误处理机制 Golang 的并发错误处理机制也更加简洁和有效。它能够帮助开发者更快速地定位和解决并发环境中可能出现的问题，减少了因并发导致的错误排查难度和时间成本。 func worker(ch chan\u003c- Result) { res, err := compute() if err != nil { ch \u003c- Result{Err: err} // 错误通过Channel返回 return } ch \u003c- Result{Data: res} } 优势： 统一错误流：错误与结果同通道传递，避免并发场景下的异常丢失 defer资源回收：确保Goroutine退出时自动释放资源 三、优秀的内存管理和并发调度 在编程语言中，内存管理和并发调度是影响程序性能和稳定性的关键因素。Golang 在这两个方面展现出了卓越的特性。 1.Golang 内存管理机制（三级缓存架构） Golang 拥有一套自动且高效的内存回收机制。这意味着开发者无需像在 Java 等语言中那样，时刻关注内存的分配与释放，避免了因手动管理内存而可能导致的内存泄漏和野指针等问题。这种自动内存管理机制不仅减轻了开发者的负担，还提高了程序的可靠性和可维护性。 层级 组件 对象大小 锁机制 功能特点 线程本地缓存 mcache \u003c 32KB 无锁（P 独占） 每个 P（处理器）独立缓存小对象，分配速度极快，减少全局竞争。 中心缓存 mcentral 16B - 32KB 需加锁 全局共享，按大小分类管理 Span，为 mcache 提供后备资源。 全局堆 mheap ≥ 32KB 需加锁 管理大对象和操作系统内存申请，处理跨 Span 分配，碎片整理由 GC 完成。 优化设计： 对象分级：67 种 Size Class（如 8B/16B/32B），减少内存碎片 逃逸分析：编译器自动判断对象分配在栈（局部变量）或堆（跨作用域），减少 GC 压力 对象池：sync.Pool 重用对象，避免高频分配 2.并发调度策略对比（GMP 模型） Golang 的并发调度机制极具智能性。它能够根据系统的负载和各个 Goroutine 的状态，合理地分配 CPU 资源，确保每个 Goroutine 都能获得公平的执行机会。与 Java 等语言的线程调度相比，Golang 的调度更加轻量和灵活，能够在高并发场景下实现更高效的资源利用，从而显著提升程序的整体性能和响应速度。 策略 触发条件 抢占点 优势 工作窃取（Work Stealing） P 的本地队列为空 本地队列无任务时 负载均衡：P 从全局队列或其他 P 偷取 G，提升 CPU 利用率。 协作式调度 G 主动让出（如 runtime.Gosched()） 函数调用点 低开销：无强制中断，但可能因阻塞导致饥饿（Go 1.14 式）。 抢占式调度 G 运行超时（10ms） 异步安全点 公平性：强制切换长时间运行的 G，避免“饿死”（Go 1.14 式）。 调度组件： Goroutine（G）：轻量级协程（初始栈 2KB，可动态扩展） Machine（M）：OS 线程，绑定 P 执行 G Processor（P）：逻辑处理器，管理本地队列（最多存放 256 个 G） 通过三级内存缓存降低锁竞争，结合智能调度策略（窃取+抢占），Golang 在保证自动内存安全的同时，实现高并发场景下的低延迟与高吞吐。 ","date":"2025-01-12","objectID":"/posts/the_concurrency_advantage_of_go/:0:0","tags":["Golang","并发"],"title":"Go 的并发优势","uri":"/posts/the_concurrency_advantage_of_go/"},{"categories":["Golang"],"content":"下载Golang 官网链接：https://golang.google.cn/dl/ 配置环境 安装好之后须添加如下环境变量： 变更名 变量值 说明 GOPATH E:\\gowork Go语言的工作目录，存放自己编写的 .go 文件、项目、包、编译的二进制文件等 GOROOT D:\\go Go的安装路径 在 Path 路径下，新增 %GOROOT%\\bin ps: GOPATH 的值，需要根据实际情况按需配置，默认路径为C盘用户目录下 开启go mod 及配置国内代理： go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct 配置vscode 安装 Go、vscode-go-syntax 两插件 届时，vscode 会弹出需要安装其他 go 扩展的提示，点击 Install All 即可 如条件允许更推荐使用 GoLand 进行开发 ","date":"2025-01-12","objectID":"/posts/golang_development_environment/:0:0","tags":["Golang"],"title":"Golang 开发环境搭建","uri":"/posts/golang_development_environment/"},{"categories":null,"content":"关于我 一名后端工程师，热衷于钻研感兴趣之事，追求那点滴成就感，在代码世界中持续探索边界。 教育经历：计算机科学与技术专业 使用语言：Go / Java / Python 从业经历：4年开发经验，现于某一线互联网公司工作 开源项目：In development… 关于博客 不定期记录技术实践与思考，分享踩坑经验与解决方案，偶尔也聊点生活日常。 如需转载或引用内容，请参考本站 声明。 欢迎通过我的 GitHub 或 RSS 订阅本博客。 博客历程 因 CSDN 平台商业化与内容同质化问题日益严重，最终决定注销账号，转向 Github Page 自建博客平台。 2025在 CSDN 持续输出技术内容，多篇文章获得高赞收藏，也曾跻身平台周榜 Top5。 2021因博客园界面风格过于复古，尝试多种美化方案仍难满意，而后转战 CSDN。 2020在 博客园 注册自己的第一个博客，发表了几篇随笔，收获不少访问量，心中大喜。 2019大学生活伊始，便一头扎进了编程的世界，开启了技术探索之旅，受 狂胜 启发开启博客创作。 2018 联系我 技术交流： 留言板 Email： chihpengliu.cn@outlook.com ","date":"2025-01-12","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":" 本站信息 昵称 : Vespeng 头像 : https://vespeng.tech/avatar.jpg URL : https://vespeng.tech 描述 : 不定期记录开发路上的片段，与君共勉 交换方式 如需申请友情链接，请在评论区按如下格式留言提交： 友情提示：以上排名不分先后，为保证链接有效性，失效地址将定期清理，如更换域名，请及时联系。 - nickname: \u003cyour nickname\u003e avatar: \u003cyour avatar\u003e url: \u003cyour site link\u003e description: \u003cdescription of your site\u003e ","date":"2025-01-12","objectID":"/link/:0:0","tags":null,"title":"友情链接","uri":"/link/"}]